<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta Tags and Title -->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    
    <!-- Custom Styles -->
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
            position: relative;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            margin-top: 20px;
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 5px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 60px;
            height: 40px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #cccccc;
        }
        .th-name {
            margin-left: 25px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
        /* Debug Logs Styling */
        #debugLogs {
            background-color: #1e1e1e;
            padding: 10px;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            font-family: monospace;
            color: #ff6f61;
        }
        /* Customize Columns Styling */
        #sortableColumns .column-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            cursor: grab;
            padding: 5px 10px;
            background-color: #1e1e1e;
            border: 1px solid #444;
            color: #ffffff;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        #sortableColumns .column-item.dragging {
            opacity: 0.5;
        }
        /* Checkbox and Label Styling */
        #sortableColumns .form-check-input {
            accent-color: #00bcd4;
        }
        #sortableColumns .form-check-label {
            margin-left: 5px;
        }
        /* Active Refresh Interval Button Styling */
        .refresh-interval-button.active {
            background-color: #00bcd4;
            color: #fff;
        }
        /* Reset Database Button Styling */
        .reset-db-button {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav"
                aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse navbar-collapse" id="navbarNav">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Filter Section -->
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>

        <!-- Portfolio Table -->
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr id="portfolioHeaders">
                        <!-- Dynamic Headers will be inserted here -->
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row" id="totalsRow">
                        <!-- Totals will be inserted here -->
                    </tr>
                </tfoot>
            </table>
        </div>

        <!-- Auto-Refresh Interval Section -->
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>

        <!-- Settings Toggle -->
        <div class="settings-toggle text-end mt-4">
            <span id="settingsIcon"><i class="fas fa-cog"></i> Settings</span>
        </div>

        <!-- Settings Section -->
        <div class="settings d-none" id="settings">
            <h3>Settings</h3>
            <!-- Column Customization -->
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" class="list-group">
                    <!-- List items will be populated dynamically by JavaScript -->
                </ul>
                <button id="resetSettings" class="btn btn-secondary mt-3">Reset to Default</button>
            </div>

            <!-- API Keys Section -->
            <div class="mb-3">
                <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
                <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            </div>
            <div class="mb-3">
                <label for="alpacaApiSecret" class="form-label">Alpaca API Secret:</label>
                <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            </div>
            <div class="mb-3">
                <label for="finnhubApiKey" class="form-label">Finnhub API Key:</label>
                <input type="text" id="finnhubApiKey" class="form-control" placeholder="Enter your Finnhub API Key">
            </div>
            <button id="saveKeys" class="btn btn-primary">Save Settings</button>

            <!-- Reset Database Button -->
            <button id="resetDatabase" class="btn btn-danger reset-db-button">
                <i class="fas fa-database"></i> Reset Database
            </button>
        </div>

        <!-- Debug Logs Section -->
        <div id="debugLogs"></div>
    </div>

    <!-- Bootstrap JS and Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Font Awesome JS for Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/js/all.min.js"></script>
    
    <!-- Main JavaScript -->
    <script>
        // Database Configuration
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        // State Variables
        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let visibleColumns = [
            "tickerSymbol",
            "avgPrice",
            "numShares",
            "lastPrice",
            "costBasis",
            "totalValue",
            "profit",
            "profitPct",
            "changeToday",
            "changePctToday",
            "gapPct",
            "lastTime"
        ];

        // Define the available columns
        const availableColumns = [
            { key: "tickerSymbol", name: "Ticker" },
            { key: "avgPrice", name: "Average Price" },
            { key: "numShares", name: "Shares" },
            { key: "lastPrice", name: "Current Price" },
            { key: "costBasis", name: "Cost Basis" },
            { key: "totalValue", name: "Total Value" },
            { key: "profit", name: "Profit" },
            { key: "profitPct", name: "Profit %" },
            { key: "changeToday", name: "Change Today" },
            { key: "changePctToday", name: "Change % Today" },
            { key: "gapPct", name: "Gap %" },
            { key: "lastTime", name: "Time Since Last Trade" }
        ];

        // Function to Append Debug Logs
        function appendDebugLog(message) {
            const debugLogs = document.getElementById("debugLogs");
            const logEntry = document.createElement("div");
            logEntry.textContent = message;
            debugLogs.appendChild(logEntry);
            // Auto-scroll to the bottom
            debugLogs.scrollTop = debugLogs.scrollHeight;
        }

        // Function to Open IndexedDB
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 3); // Increment version if schema changes

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(positionsStoreName)) {
                        const positionsStore = db.createObjectStore(positionsStoreName, { keyPath: "id" });
                        positionsStore.createIndex("tickerSymbol", "tickerSymbol", { unique: false });
                    }
                    if (!db.objectStoreNames.contains(settingsStoreName)) {
                        db.createObjectStore(settingsStoreName, { keyPath: "key" });
                    }
                };

                request.onsuccess = (event) => {
                    resolve(event.target.result);
                };

                request.onerror = (event) => {
                    reject(event.target.error);
                };
            });
        }

        // Function to Update Positions Store with Latest Data
        async function updatePositionsStore(prices) {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readwrite");
                const store = transaction.objectStore(positionsStoreName);

                // Create an array of promises for all get and put operations
                const updatePromises = Object.entries(prices).map(([ticker, priceData]) => {
                    return new Promise((resolve, reject) => {
                        const getRequest = store.get(ticker);
                        getRequest.onsuccess = (event) => {
                            let position = event.target.result;
                            if (position) {
                                // Update existing position with latest data
                                position.lastPrice = priceData.price;
                                position.lastTime = priceData.time;
                                position.openPrice = priceData.open;
                                position.prevClosePrice = priceData.prevClose;

                                const updateRequest = store.put(position);
                                updateRequest.onsuccess = () => {
                                    console.log(`Position ${ticker} updated successfully.`);
                                    appendDebugLog(`Position ${ticker} updated successfully.`);
                                    resolve();
                                };
                                updateRequest.onerror = (event) => {
                                    console.error(`Error updating position ${ticker}:`, event.target.error);
                                    appendDebugLog(`Error updating position ${ticker}: ${event.target.error}`);
                                    reject(event.target.error);
                                };
                            } else {
                                // Position does not exist, create a new one
                                const newPosition = {
                                    id: ticker,
                                    tickerSymbol: ticker,
                                    avgPrice: 0, // Placeholder, should be set elsewhere
                                    numShares: 0, // Placeholder, should be set elsewhere
                                    lastPrice: priceData.price,
                                    costBasis: 0, // Placeholder, should be calculated
                                    totalValue: 0, // Placeholder, should be calculated
                                    profit: 0, // Placeholder, should be calculated
                                    profitPct: 0, // Placeholder, should be calculated
                                    changeToday: 0, // Placeholder, should be calculated
                                    changePctToday: 0, // Placeholder, should be calculated
                                    gapPct: 0, // Placeholder, should be calculated
                                    lastTime: priceData.time,
                                    openPrice: priceData.open,
                                    prevClosePrice: priceData.prevClose,
                                    hide: false
                                };

                                const addRequest = store.add(newPosition);
                                addRequest.onsuccess = () => {
                                    console.log(`Position ${ticker} added successfully.`);
                                    appendDebugLog(`Position ${ticker} added successfully.`);
                                    resolve();
                                };
                                addRequest.onerror = (event) => {
                                    console.error(`Error adding position ${ticker}:`, event.target.error);
                                    appendDebugLog(`Error adding position ${ticker}: ${event.target.error}`);
                                    reject(event.target.error);
                                };
                            }
                        };
                        getRequest.onerror = (event) => {
                            console.error(`Error fetching position ${ticker}:`, event.target.error);
                            appendDebugLog(`Error fetching position ${ticker}: ${event.target.error}`);
                            reject(event.target.error);
                        };
                    });
                });

                // Wait for all update operations to complete
                await Promise.all(updatePromises);

                // After updating the store, refresh allPositions with latest data
                allPositions = await fetchVisiblePositions();

                // Now, render the updated portfolio
                renderPortfolio();

                // Handle transaction completion
                transaction.oncomplete = () => {
                    // Transaction completed successfully
                };

                transaction.onerror = (event) => {
                    console.error("Transaction error while updating positions:", event.target.error);
                    appendDebugLog(`Transaction error while updating positions: ${event.target.error}`);
                };

                transaction.onabort = () => {
                    console.error("Transaction aborted while updating positions.");
                    appendDebugLog("Transaction aborted while updating positions.");
                };
            } catch (error) {
                console.error("Failed to update Positions store:", error);
                appendDebugLog(`Failed to update Positions store: ${error}`);
            }
        }

        // Function to Populate Sortable Columns
        function populateSortableColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            sortableColumns.innerHTML = ""; // Clear existing list items

            // First, add columns in the order of visibleColumns
            visibleColumns.forEach(columnKey => {
                const column = availableColumns.find(col => col.key === columnKey);
                if (column) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Then, add the remaining columns not in visibleColumns
            availableColumns.forEach(column => {
                if (!visibleColumns.includes(column.key)) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Initialize Drag-and-Drop Functionality
            initializeDragAndDrop();

            console.log("Sortable columns populated successfully.");
            appendDebugLog("Sortable columns populated successfully.");
        }

        // Helper Function to Create a Column List Item
        function createColumnListItem(column) {
            const li = document.createElement("li");
            li.className = "column-item list-group-item d-flex align-items-center";
            li.setAttribute("data-column", column.key);
            li.setAttribute("draggable", "true");

            li.innerHTML = `
                <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                <div class="form-check">
                    <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-${column.key}" value="${column.key}" ${visibleColumns.includes(column.key) ? "checked" : ""}>
                    <label class="form-check-label text-light" for="checkbox-${column.key}">${column.name}</label>
                </div>
            `;

            // Add Event Listener for Checkbox Change
            li.querySelector('.column-checkbox').addEventListener('change', () => {
                updateVisibleColumns();
                renderPortfolio();
            });

            return li;
        }

        // Function to Initialize Drag-and-Drop for Sortable Columns
        function initializeDragAndDrop() {
            const sortableColumns = document.getElementById("sortableColumns");
            let dragSrcEl = null;

            function handleDragStart(e) {
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', null); // For Firefox compatibility
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary to allow drop
                }
                e.dataTransfer.dropEffect = 'move'; // Show move cursor
                return false;
            }

            function handleDragEnter(e) {
                this.classList.add('over');
            }

            function handleDragLeave(e) {
                this.classList.remove('over');
            }

            function handleDrop(e) {
                if (e.stopPropagation) {
                    e.stopPropagation(); // Stops the browser from redirecting.
                }

                if (dragSrcEl !== this) {
                    // Reorder the DOM elements by inserting the dragged element before the drop target
                    sortableColumns.insertBefore(dragSrcEl, this);

                    // Update visibleColumns based on new order
                    updateVisibleColumns();
                    renderPortfolio();
                }
                return false;
            }

            function handleDragEnd(e) {
                this.classList.remove('dragging');
                const items = sortableColumns.querySelectorAll('.column-item');
                items.forEach(function (item) {
                    item.classList.remove('over');
                });
            }

            function addDnDHandlers(elem) {
                elem.addEventListener('dragstart', handleDragStart, false);
                elem.addEventListener('dragenter', handleDragEnter, false);
                elem.addEventListener('dragover', handleDragOver, false);
                elem.addEventListener('dragleave', handleDragLeave, false);
                elem.addEventListener('drop', handleDrop, false);
                elem.addEventListener('dragend', handleDragEnd, false);
            }

            const items = sortableColumns.querySelectorAll('.column-item');
            items.forEach(function(item) {
                addDnDHandlers(item);
            });
        }

        // Function to Update Visible Columns Order and Visibility Based on Column Settings
        async function updateVisibleColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            const columnItems = sortableColumns.querySelectorAll('.column-item');
            visibleColumns = Array.from(columnItems)
                .filter(item => item.querySelector('.column-checkbox').checked)
                .map(item => item.getAttribute('data-column'));

            // Ensure uniqueness to prevent duplicate columns
            visibleColumns = [...new Set(visibleColumns)];

            console.log("Updated visibleColumns:", visibleColumns);
            appendDebugLog("Updated visibleColumns.");

            // Save visibleColumns to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "visibleColumns", value: visibleColumns });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
                appendDebugLog("Visible columns saved to settings.");
            } catch (error) {
                console.error("Error saving visible columns:", error);
                appendDebugLog(`Error saving visible columns: ${error}`);
            }
        }

        // Function to Load Portfolio Data
        async function loadPortfolio() {
            allPositions = await fetchVisiblePositions();
            // Calculate and append additional fields to each position
            allPositions = allPositions.map(position => {
                const currentPrice = position.lastPrice || 0;
                const costBasis = position.avgPrice * position.numShares;
                const totalValue = currentPrice * position.numShares;
                const profit = totalValue - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = position.changeToday || 0;
                const changePctToday = position.changePctToday || 0;
                const gapPct = position.gapPct || 0;
                const timeSinceLastTrade = position.lastTime || "N/A";

                return {
                    ...position,
                    costBasis,
                    totalValue,
                    profit,
                    profitPct,
                    changeToday,
                    changePctToday,
                    gapPct,
                    timeSinceLastTrade
                };
            });

            // Fetch all unique tickers, including hidden ones
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);
            sortPositions(); // Ensure positions are sorted before rendering
            renderPortfolio();
        }

        // Function to Render Portfolio Table
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    updateSortSettings(sortColumn, sortDirection);
                    sortPositions();
                    renderPortfolio();
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``;
                return;
            }

            // Accumulate totals
            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const currentPrice = position.lastPrice || 0;
                const lastTime = position.lastTime || "N/A";
                const openPrice = position.openPrice || 0;
                const prevClosePrice = position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        // Function to Get Sort Type Based on Column Key
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        // Function to Get Display Name for Column
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        // Function to Calculate Time Since Last Trade
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        // Function to Sort Positions
        function sortPositions() {
            if (!sortColumn) return;

            // Sort the updated positions based on the selected column and direction
            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                if (getSortType(sortColumn) === "string") {
                    valA = (valA || "").toUpperCase(); // Handle undefined or null
                    valB = (valB || "").toUpperCase(); // Handle undefined or null
                    return sortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    valA = valA || 0; // Handle undefined or null
                    valB = valB || 0; // Handle undefined or null
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
            });
            // Persist sort settings to IndexedDB
            updateSortSettings(sortColumn, sortDirection);
        }

        // Function to update sort settings in IndexedDB
        async function updateSortSettings(column, direction) {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                // Store sort column
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "sortColumn", value: column });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });

                // Store sort direction
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "sortDirection", value: direction });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });

                appendDebugLog(`Sort settings updated: column=${column}, direction=${direction}`);
            } catch (error) {
                console.error("Error updating sort settings:", error);
                appendDebugLog(`Error updating sort settings: ${error}`);
            }
        }

        // Function to Load Sort Settings from IndexedDB
        async function loadSortSettings() {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                const sortColumnRequest = store.get("sortColumn");
                const sortDirectionRequest = store.get("sortDirection");

                const [sortColumnResult, sortDirectionResult] = await Promise.all([
                    new Promise((resolve, reject) => {
                        sortColumnRequest.onsuccess = (event) => resolve(event.target.result?.value || null);
                        sortColumnRequest.onerror = (event) => reject(event.target.error);
                    }),
                    new Promise((resolve, reject) => {
                        sortDirectionRequest.onsuccess = (event) => resolve(event.target.result?.value || 'asc');
                        sortDirectionRequest.onerror = (event) => reject(event.target.error);
                    })
                ]);

                if (sortColumnResult) {
                    sortColumn = sortColumnResult;
                }
                if (sortDirectionResult) {
                    sortDirection = sortDirectionResult;
                }

                appendDebugLog("Sort settings loaded.");
            } catch (error) {
                console.error("Error loading sort settings:", error);
                appendDebugLog(`Error loading sort settings: ${error}`);
            }
        }

        // Function to Fetch Visible Positions from IndexedDB
        async function fetchVisiblePositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => {
                    const all = event.target.result;
                    // Filter out positions where hide is true
                    const visible = all.filter(position => !position.hide);
                    resolve(visible);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch All Unique Tickers from IndexedDB
        async function fetchAllTickers() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index.openCursor(null, "nextunique");
                const tickers = [];
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        tickers.push(cursor.key);
                        cursor.continue();
                    } else {
                        resolve(tickers);
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Generate Filter Checkboxes
        async function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            const db = await openDatabase();
            const store = db.transaction(positionsStoreName, "readonly").objectStore(positionsStoreName);

            for (const ticker of uniqueTickers) {
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" checked>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                // Determine the initial checked state based on positions' hide attribute
                const request = store.index && store.index("tickerSymbol") ? store.index("tickerSymbol").getAll(ticker) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === ticker);
                    const isHidden = positions.every(pos => pos.hide);
                    if (isHidden) {
                        checkbox.querySelector('input').checked = false;
                    } else {
                        checkbox.querySelector('input').checked = true;
                    }
                };
                request.onerror = (event) => {
                    console.error(`Error fetching positions for ${ticker}:`, event.target.error);
                };

                // Add Event Listener for Checkbox Change
                checkbox.querySelector('input').addEventListener("change", async () => {
                    const ticker = checkbox.querySelector("input").value;
                    const isChecked = checkbox.querySelector("input").checked;
                    const hide = !isChecked;

                    // Update the 'hide' attribute for all positions with this tickerSymbol
                    try {
                        await setHideForTickerSymbol(ticker, hide);
                        console.log(`Set hide=${hide} for tickerSymbol=${ticker}`);
                        appendDebugLog(`Set hide=${hide} for tickerSymbol=${ticker}`);

                        // Reload portfolio after updating hide status
                        await loadPortfolio();
                    } catch (error) {
                        console.error(`Error setting hide for tickerSymbol=${ticker}:`, error);
                        appendDebugLog(`Error setting hide for tickerSymbol=${ticker}: ${error}`);
                    }
                });

                filterCheckboxes.appendChild(checkbox);
            }
        }

        // Function to Update the 'hide' Attribute for All Positions with a Specific Ticker Symbol
        async function setHideForTickerSymbol(tickerSymbol, hide) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index ? index.getAll(tickerSymbol) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === tickerSymbol);
                    for (const position of positions) {
                        position.hide = hide;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    resolve();
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch Current Prices
        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                const alpacaKey = await new Promise((resolve, reject) => {
                    const request = store.get("APCA_API_KEY_ID");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                const alpacaSecret = await new Promise((resolve, reject) => {
                    const request = store.get("APCA_API_SECRET_KEY");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                if (alpacaKey && alpacaSecret) {
                    return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
                }

                console.warn("Alpaca credentials not available, falling back to Finnhub.");
                appendDebugLog("Alpaca credentials not available, falling back to Finnhub.");
                const finnhubKey = await new Promise((resolve, reject) => {
                    const request = store.get("finnhubApiKey");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                if (!finnhubKey) {
                    console.error("Finnhub API Key is not set. Please configure it in the settings.");
                    appendDebugLog("Finnhub API Key is not set. Please configure it in the settings.");
                    return {};
                }

                return await fetchPricesFromFinnhub(tickers, finnhubKey);
            } catch (error) {
                console.error("Error fetching current prices:", error);
                appendDebugLog(`Error fetching current prices: ${error}`);
                return {};
            }
        }

        // Fetch Prices from Alpaca
        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                for (const [symbol, snapshot] of Object.entries(data)) {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t ? new Date(snapshot.latestTrade.t).toLocaleString() : "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };
                }

                console.log("Fetched prices from Alpaca:", prices);
                appendDebugLog("Fetched prices from Alpaca.");
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                appendDebugLog(`Error fetching snapshots from Alpaca: ${error}`);
                return {};
            }
        }

        // Fetch Prices from Finnhub
        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            appendDebugLog(`Failed to fetch quote data for ${ticker} from Finnhub: ${quoteResponse.statusText}`);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                            appendDebugLog(`Failed to fetch previous close data for ${ticker} from Finnhub: ${prevCloseResponse.statusText}`);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                appendDebugLog("Fetched prices from Finnhub.");
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                appendDebugLog(`Error fetching prices from Finnhub: ${error}`);
                return {};
            }
        }

        // Function to Fetch and Update Positions
        async function fetchAndUpdatePositions() {
            try {
                appendDebugLog("Auto-refresh initiated.");
                const db = await openDatabase();
                const visiblePositions = await fetchVisiblePositions();
                const tickers = visiblePositions.map(pos => pos.tickerSymbol);
                const uniqueTickers = [...new Set(tickers)];
                appendDebugLog(`Tickers to fetch: ${uniqueTickers.join(", ")}`);
                const prices = await fetchCurrentPrices(uniqueTickers);
                appendDebugLog(`Fetched prices: ${JSON.stringify(prices)}`);
                await updatePositionsStore(prices);

                // Re-fetch allPositions after updating the store
                allPositions = await fetchVisiblePositions();

                // Re-apply sorting before rendering
                sortPositions(); 

                renderPortfolio(); 
                appendDebugLog("Auto-refresh completed successfully.");
            } catch (error) {
                console.error("Error in fetchAndUpdatePositions:", error);
                appendDebugLog(`Error in fetchAndUpdatePositions: ${error}`);
            }
        }

        // Function to Initialize Auto-Refresh
        function initializeAutoRefresh() {
            const buttons = document.querySelectorAll(".refresh-interval-button");
            buttons.forEach(button => {
                button.addEventListener("click", () => {
                    buttons.forEach(btn => btn.classList.remove("active"));
                    button.classList.add("active");
                    const interval = parseInt(button.getAttribute("data-interval"));

                    if (refreshIntervalId) {
                        clearInterval(refreshIntervalId);
                        refreshIntervalId = null;
                        appendDebugLog("Auto-refresh stopped.");
                    }

                    if (interval > 0) {
                        refreshIntervalId = setInterval(fetchAndUpdatePositions, interval * 1000);
                        appendDebugLog(`Auto-refresh set to every ${interval} seconds.`);
                        // Immediately fetch data when auto-refresh is started
                        fetchAndUpdatePositions();
                    } else {
                        appendDebugLog("Auto-refresh stopped.");
                    }
                });
            });
        }

        // Function to Load Sort Settings from IndexedDB
        async function loadSortSettings() {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                const sortColumnRequest = store.get("sortColumn");
                const sortDirectionRequest = store.get("sortDirection");

                const [sortColumnResult, sortDirectionResult] = await Promise.all([
                    new Promise((resolve, reject) => {
                        sortColumnRequest.onsuccess = (event) => resolve(event.target.result?.value || null);
                        sortColumnRequest.onerror = (event) => reject(event.target.error);
                    }),
                    new Promise((resolve, reject) => {
                        sortDirectionRequest.onsuccess = (event) => resolve(event.target.result?.value || 'asc');
                        sortDirectionRequest.onerror = (event) => reject(event.target.error);
                    })
                ]);

                if (sortColumnResult) {
                    sortColumn = sortColumnResult;
                }
                if (sortDirectionResult) {
                    sortDirection = sortDirectionResult;
                }

                appendDebugLog("Sort settings loaded.");
            } catch (error) {
                console.error("Error loading sort settings:", error);
                appendDebugLog(`Error loading sort settings: ${error}`);
            }
        }

        // Function to Initialize Settings
        async function initializeSettings() {
            await populateSortableColumns();
            await loadSortSettings();
            await loadPortfolio();
        }

        // Function to Handle Settings Toggle
        function handleSettingsToggle() {
            const settingsToggle = document.getElementById("settingsToggle");
            const settings = document.getElementById("settings");

            document.getElementById("settingsIcon").addEventListener("click", () => {
                settings.classList.toggle("d-none");
                appendDebugLog("Settings panel toggled.");
            });

            // Reset Settings Button
            document.getElementById("resetSettings").addEventListener("click", async () => {
                visibleColumns = [
                    "tickerSymbol",
                    "avgPrice",
                    "numShares",
                    "lastPrice",
                    "costBasis",
                    "totalValue",
                    "profit",
                    "profitPct",
                    "changeToday",
                    "changePctToday",
                    "gapPct",
                    "lastTime"
                ];
                await updateVisibleColumns();
                populateSortableColumns();
                renderPortfolio();
                appendDebugLog("Settings reset to default.");
            });
        }

        // Function to Handle Save Keys
        async function handleSaveKeys() {
            document.getElementById("saveKeys").addEventListener("click", async () => {
                const alpacaApiKey = document.getElementById("alpacaApiKey").value.trim();
                const alpacaApiSecret = document.getElementById("alpacaApiSecret").value.trim();
                const finnhubApiKey = document.getElementById("finnhubApiKey").value.trim();

                try {
                    const db = await openDatabase();
                    const transaction = db.transaction(settingsStoreName, "readwrite");
                    const store = transaction.objectStore(settingsStoreName);

                    if (alpacaApiKey) {
                        store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
                    }
                    if (alpacaApiSecret) {
                        store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
                    }
                    if (finnhubApiKey) {
                        store.put({ key: "finnhubApiKey", value: finnhubApiKey });
                    }

                    await new Promise((resolve, reject) => {
                        transaction.oncomplete = () => resolve();
                        transaction.onerror = (event) => reject(event.target.error);
                    });

                    appendDebugLog("API keys saved successfully.");
                    alert("API keys saved successfully.");
                } catch (error) {
                    console.error("Error saving API keys:", error);
                    appendDebugLog(`Error saving API keys: ${error}`);
                    alert("Failed to save API keys. Please try again.");
                }
            });
        }

        // Function to Handle Reset Database
        async function handleResetDatabase() {
            document.getElementById("resetDatabase").addEventListener("click", async () => {
                if (confirm("Are you sure you want to reset the database? This action cannot be undone.")) {
                    try {
                        const deleteRequest = indexedDB.deleteDatabase(dbName);
                        deleteRequest.onsuccess = () => {
                            appendDebugLog("Database reset successfully.");
                            alert("Database reset successfully.");
                            window.location.reload();
                        };
                        deleteRequest.onerror = (event) => {
                            console.error("Error resetting database:", event.target.error);
                            appendDebugLog(`Error resetting database: ${event.target.error}`);
                            alert("Failed to reset the database. Please try again.");
                        };
                        deleteRequest.onblocked = () => {
                            console.warn("Database reset blocked.");
                            appendDebugLog("Database reset blocked.");
                            alert("Database reset is blocked. Please close other tabs using this site and try again.");
                        };
                    } catch (error) {
                        console.error("Error during database reset:", error);
                        appendDebugLog(`Error during database reset: ${error}`);
                        alert("An error occurred while resetting the database.");
                    }
                }
            });
        }

        // Function to Initialize Event Listeners
        function initializeEventListeners() {
            // Event Listener for Settings Toggle
            handleSettingsToggle();

            // Event Listener for Save Keys Button
            handleSaveKeys();

            // Event Listener for Reset Database Button
            handleResetDatabase();
        }

        // Function to Initialize the Application
        async function initializeApp() {
            await initializeSettings();
            initializeEventListeners();
            initializeAutoRefresh();
            fetchAndUpdatePositions(); // Initial fetch
        }

        // Call initializeApp on page load
        window.addEventListener("load", initializeApp);
    </script>
</body>
</html>