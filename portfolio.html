<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
            position: relative;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            margin-top: 20px;
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 5px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 60px;
            height: 40px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #cccccc;
        }
        .th-name {
            margin-left: 25px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
        /* Debug Logs Styling */
        #debugLogs {
            background-color: #1e1e1e;
            padding: 10px;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            display: block;
        }
        /* Customize Columns Styling */
        #sortableColumns .column-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            cursor: grab;
            padding: 5px 10px;
            background-color: #1e1e1e;
            border: 1px solid #444;
            color: #ffffff;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        #sortableColumns .column-item.dragging {
            opacity: 0.5;
        }
        /* Checkbox and Label Styling */
        #sortableColumns .form-check-input {
            accent-color: #00bcd4;
        }
        #sortableColumns .form-check-label {
            margin-left: 5px;
        }
        /* Active Refresh Interval Button Styling */
        .refresh-interval-button.active {
            background-color: #00bcd4;
            color: #fff;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Filter Section -->
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>

        <!-- Portfolio Table -->
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr id="portfolioHeaders">
                        <!-- Dynamic Headers will be inserted here -->
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row" id="totalsRow">
                        <!-- Totals will be inserted here -->
                    </tr>
                </tfoot>
            </table>
        </div>

        <!-- Auto-Refresh Interval Section -->
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>

        <!-- Settings Toggle -->
        <div class="settings-toggle text-end mt-4">
            <span id="settingsIcon"><i class="fas fa-cog"></i> Settings</span>
        </div>

        <!-- Settings Section -->
        <div class="settings d-none" id="settings">
            <h3>Settings</h3>
            <!-- Column Customization -->
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" class="list-group">
                    <!-- List items will be populated dynamically by JavaScript -->
                </ul>
                <button id="resetSettings" class="btn btn-secondary mt-3">Reset to Default</button>
            </div>

            <!-- API Keys Section -->
            <div class="mb-3">
                <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
                <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            </div>
            <div class="mb-3">
                <label for="alpacaApiSecret" class="form-label">Alpaca API Secret:</label>
                <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            </div>
            <div class="mb-3">
                <label for="finnhubApiKey" class="form-label">Finnhub API Key:</label>
                <input type="text" id="finnhubApiKey" class="form-control" placeholder="Enter your Finnhub API Key">
            </div>
            <button id="saveKeys" class="btn btn-primary">Save Settings</button>
        </div>

        <!-- Debug Logs Section -->
        <div id="debugLogs"></div>
    </div>

    <!-- Bootstrap JS and Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Font Awesome JS for Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/js/all.min.js"></script>
    <!-- Main JavaScript -->
    <script>
        // Database Configuration
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        // State Variables
        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let visibleColumns = [
            "tickerSymbol",
            "avgPrice",
            "numShares",
            "lastPrice",
            "costBasis",
            "totalValue",
            "profit",
            "profitPct",
            "changeToday",
            "changePctToday",
            "gapPct",
            "lastTime"
        ];

        // Define the available columns
        const availableColumns = [
            { key: "tickerSymbol", name: "Ticker" },
            { key: "avgPrice", name: "Average Price" },
            { key: "numShares", name: "Shares" },
            { key: "lastPrice", name: "Current Price" },
            { key: "costBasis", name: "Cost Basis" },
            { key: "totalValue", name: "Total Value" },
            { key: "profit", name: "Profit" },
            { key: "profitPct", name: "Profit %" },
            { key: "changeToday", name: "Change Today" },
            { key: "changePctToday", name: "Change % Today" },
            { key: "gapPct", name: "Gap %" },
            { key: "lastTime", name: "Time Since Last Trade" }
        ];

        // Function to Append Debug Logs (Optional)
        function appendDebugLog(message) {
            const debugLogs = document.getElementById("debugLogs");
            const logEntry = document.createElement("div");
            logEntry.textContent = message;
            debugLogs.appendChild(logEntry);
        }

        // Function to Populate Sortable Columns
        function populateSortableColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            sortableColumns.innerHTML = ""; // Clear existing list items

            // First, add columns in the order of visibleColumns
            visibleColumns.forEach(columnKey => {
                const column = availableColumns.find(col => col.key === columnKey);
                if (column) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Then, add the remaining columns not in visibleColumns
            availableColumns.forEach(column => {
                if (!visibleColumns.includes(column.key)) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Initialize Drag-and-Drop Functionality
            initializeDragAndDrop();

            console.log("Sortable columns populated successfully.");
            appendDebugLog("Sortable columns populated successfully.");
        }

        // Helper Function to Create a Column List Item
        function createColumnListItem(column) {
            const li = document.createElement("li");
            li.className = "column-item list-group-item d-flex align-items-center";
            li.setAttribute("data-column", column.key);
            li.setAttribute("draggable", "true");

            li.innerHTML = `
                <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                <div class="form-check">
                    <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-${column.key}" value="${column.key}" ${visibleColumns.includes(column.key) ? "checked" : ""}>
                    <label class="form-check-label text-light" for="checkbox-${column.key}">${column.name}</label>
                </div>
            `;

            // Add Event Listener for Checkbox Change
            li.querySelector('.column-checkbox').addEventListener('change', () => {
                updateVisibleColumns();
                renderPortfolio();
            });

            return li;
        }

        // Function to Initialize Drag-and-Drop for Sortable Columns
        function initializeDragAndDrop() {
            const sortableColumns = document.getElementById("sortableColumns");
            let dragSrcEl = null;

            function handleDragStart(e) {
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', null); // For Firefox compatibility
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary to allow drop
                }
                e.dataTransfer.dropEffect = 'move'; // Show move cursor
                return false;
            }

            function handleDragEnter(e) {
                this.classList.add('over');
            }

            function handleDragLeave(e) {
                this.classList.remove('over');
            }

            function handleDrop(e) {
                if (e.stopPropagation) {
                    e.stopPropagation(); // Stops the browser from redirecting.
                }

                if (dragSrcEl !== this) {
                    // Reorder the DOM elements by inserting the dragged element before the drop target
                    sortableColumns.insertBefore(dragSrcEl, this);

                    // Update visibleColumns based on new order
                    updateVisibleColumns();
                    renderPortfolio();
                }
                return false;
            }

            function handleDragEnd(e) {
                this.classList.remove('dragging');
                const items = sortableColumns.querySelectorAll('.column-item');
                items.forEach(function (item) {
                    item.classList.remove('over');
                });
            }

            function addDnDHandlers(elem) {
                elem.addEventListener('dragstart', handleDragStart, false);
                elem.addEventListener('dragenter', handleDragEnter, false);
                elem.addEventListener('dragover', handleDragOver, false);
                elem.addEventListener('dragleave', handleDragLeave, false);
                elem.addEventListener('drop', handleDrop, false);
                elem.addEventListener('dragend', handleDragEnd, false);
            }

            const items = sortableColumns.querySelectorAll('.column-item');
            items.forEach(function(item) {
                addDnDHandlers(item);
            });
        }

        // Function to Update Visible Columns Order and Visibility Based on Column Settings
        async function updateVisibleColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            const columnItems = sortableColumns.querySelectorAll('.column-item');
            visibleColumns = Array.from(columnItems)
                .filter(item => item.querySelector('.column-checkbox').checked)
                .map(item => item.getAttribute('data-column'));

            // **Ensure uniqueness to prevent duplicate columns**
            visibleColumns = [...new Set(visibleColumns)];

            console.log("Updated visibleColumns:", visibleColumns);
            appendDebugLog("Updated visibleColumns.");

            // Save visibleColumns to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "visibleColumns", value: visibleColumns });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
                appendDebugLog("Visible columns saved to settings.");
            } catch (error) {
                console.error("Error saving visible columns:", error);
                appendDebugLog(`Error saving visible columns: ${error}`);
            }
        }

        // Function to Load Portfolio Data
        async function loadPortfolio() {
            allPositions = await fetchVisiblePositions();
            // Calculate and append additional fields to each position
            allPositions = allPositions.map(position => {
                const currentPrice = position.lastPrice || 0;
                const costBasis = position.avgPrice * position.numShares;
                const totalValue = currentPrice * position.numShares;
                const profit = totalValue - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = position.changeToday || 0;
                const changePctToday = position.changePctToday || 0;
                const gapPct = position.gapPct || 0;
                const timeSinceLastTrade = position.lastTime || "N/A";

                return {
                    ...position,
                    costBasis,
                    totalValue,
                    profit,
                    profitPct,
                    changeToday,
                    changePctToday,
                    gapPct,
                    timeSinceLastTrade
                };
            });

            // Fetch all unique tickers, including hidden ones
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);
            sortPositions(); // Sort after adding calculated fields
            renderPortfolio();
        }

        // Function to Render Portfolio Table
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    sortPositions();
                    renderPortfolio();
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``; // We'll handle it dynamically
                return;
            }

            // Fetch batched prices for all symbols
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        // Function to Get Sort Type Based on Column Key
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        // Function to Get Display Name for Column
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        // Function to Calculate Time Since Last Trade
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        // Function to Fetch Visible Positions from IndexedDB
        async function fetchVisiblePositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => {
                    const all = event.target.result;
                    // Filter out positions where hide is true
                    const visible = all.filter(position => !position.hide);
                    resolve(visible);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch All Unique Tickers from IndexedDB
        async function fetchAllTickers() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index.openCursor(null, "nextunique");
                const tickers = [];
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        tickers.push(cursor.key);
                        cursor.continue();
                    } else {
                        resolve(tickers);
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Generate Filter Checkboxes
        async function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            const db = await openDatabase();
            const store = db.transaction(positionsStoreName, "readonly").objectStore(positionsStoreName);

            for (const ticker of uniqueTickers) {
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" checked>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                // Determine the initial checked state based on positions' hide attribute
                const request = store.index && store.index("tickerSymbol") ? store.index("tickerSymbol").getAll(ticker) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === ticker);
                    const isHidden = positions.every(pos => pos.hide); // Changed to 'every' for correct logic
                    if (isHidden) {
                        checkbox.querySelector('input').checked = false;
                    } else {
                        checkbox.querySelector('input').checked = true;
                    }
                };
                request.onerror = (event) => {
                    console.error(`Error fetching positions for ${ticker}:`, event.target.error);
                };

                // Add Event Listener for Checkbox Change
                checkbox.querySelector('input').addEventListener("change", async () => {
                    const ticker = checkbox.querySelector("input").value;
                    const isChecked = checkbox.querySelector("input").checked;
                    const hide = !isChecked;

                    // Update the 'hide' attribute for all positions with this tickerSymbol
                    try {
                        await setHideForTickerSymbol(ticker, hide);
                        console.log(`Set hide=${hide} for tickerSymbol=${ticker}`);
                        appendDebugLog(`Set hide=${hide} for tickerSymbol=${ticker}`);

                        // Reload portfolio after updating hide status
                        await loadPortfolio();
                    } catch (error) {
                        console.error(`Error setting hide for tickerSymbol=${ticker}:`, error);
                        appendDebugLog(`Error setting hide for tickerSymbol=${ticker}: ${error}`);
                    }
                });

                filterCheckboxes.appendChild(checkbox);
            }
        }

        // Function to Update the 'hide' Attribute for All Positions with a Specific Ticker Symbol
        async function setHideForTickerSymbol(tickerSymbol, hide) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index ? index.getAll(tickerSymbol) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === tickerSymbol);
                    for (const position of positions) {
                        position.hide = hide;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    resolve();
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch Current Prices
        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            const alpacaKey = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_KEY_ID");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            const alpacaSecret = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_SECRET_KEY");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (alpacaKey && alpacaSecret) {
                return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
            }

            console.warn("Alpaca credentials not available, falling back to Finnhub.");
            appendDebugLog("Alpaca credentials not available, falling back to Finnhub.");
            const finnhubKey = await new Promise((resolve, reject) => {
                const request = store.get("finnhubApiKey");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (!finnhubKey) {
                console.error("Finnhub API Key is not set. Please configure it in the settings.");
                appendDebugLog("Finnhub API Key is not set. Please configure it in the settings.");
                return {};
            }

            return await fetchPricesFromFinnhub(tickers, finnhubKey);
        }

        // Fetch Prices from Alpaca
        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                for (const [symbol, snapshot] of Object.entries(data)) {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t ? new Date(snapshot.latestTrade.t).toLocaleString() : "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };
                }

                console.log("Fetched prices from Alpaca:", prices);
                appendDebugLog("Fetched prices from Alpaca.");
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                appendDebugLog(`Error fetching snapshots from Alpaca: ${error}`);
                return {};
            }
        }

        // Fetch Prices from Finnhub
        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            appendDebugLog(`Failed to fetch quote data for ${ticker} from Finnhub: ${quoteResponse.statusText}`);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                            appendDebugLog(`Failed to fetch previous close data for ${ticker} from Finnhub: ${prevCloseResponse.statusText}`);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                appendDebugLog("Fetched prices from Finnhub.");
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                appendDebugLog(`Error fetching prices from Finnhub: ${error}`);
                return {};
            }
        }

        // Function to Handle Settings Toggle
        document.getElementById("settingsIcon").addEventListener("click", () => {
            const settingsDiv = document.getElementById("settings");
            settingsDiv.classList.toggle("d-none");
        });

        // Function to Save API Keys and Refresh Interval
        document.getElementById("saveKeys").addEventListener("click", async () => {
            const alpacaApiKey = document.getElementById("alpacaApiKey").value.trim();
            const alpacaApiSecret = document.getElementById("alpacaApiSecret").value.trim();
            const finnhubApiKey = document.getElementById("finnhubApiKey").value.trim();

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);

            if (alpacaApiKey) {
                store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
                appendDebugLog("Alpaca API Key saved.");
            }

            if (alpacaApiSecret) {
                store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
                appendDebugLog("Alpaca API Secret saved.");
            }

            if (finnhubApiKey) {
                store.put({ key: "finnhubApiKey", value: finnhubApiKey });
                appendDebugLog("Finnhub API Key saved.");
            }

            document.getElementById("settingsFeedback").textContent = "Settings saved successfully!";
            document.getElementById("settingsFeedback").style.display = "block";
            setTimeout(() => {
                document.getElementById("settingsFeedback").style.display = "none";
            }, 3000);
        });

        // Function to Handle Filter Input with Debounce
        let debounceTimeout;
        document.getElementById("filterInput").addEventListener("input", () => {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                renderPortfolio();
            }, 300); // Adjust the debounce delay as needed
        });

        // Function to Initialize Auto-Refresh Interval Buttons
        async function initializeRefreshIntervalButtons() {
            const buttons = document.querySelectorAll('.refresh-interval-button');
            const db = await openDatabase();
            const store = db.transaction(settingsStoreName, "readwrite").objectStore(settingsStoreName);
            const currentInterval = await new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });

            buttons.forEach(button => {
                if (parseInt(button.getAttribute('data-interval')) === currentInterval) {
                    button.classList.add('active');
                }

                button.addEventListener('click', async () => {
                    try {
                        const interval = parseInt(button.getAttribute('data-interval'));
                        
                        // Open a new transaction for each put operation
                        const newTransaction = db.transaction(settingsStoreName, "readwrite");
                        const newStore = newTransaction.objectStore(settingsStoreName);
                        
                        // Await the completion of store.put within the new transaction
                        await new Promise((resolve, reject) => {
                            const request = newStore.put({ key: "refreshInterval", value: interval });
                            request.onsuccess = () => resolve();
                            request.onerror = (event) => reject(event.target.error);
                        });

                        appendDebugLog(`Auto-refresh interval set to ${interval} seconds.`);

                        // Update button styles
                        buttons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');

                        // Restart auto-refresh with the new interval
                        await startAutoRefresh();

                        // Provide user feedback
                        document.getElementById("settingsFeedback").textContent = interval === 0 ? "Auto-refresh stopped." : `Auto-refresh interval set to ${interval} seconds.`;
                        document.getElementById("settingsFeedback").style.display = "block";
                        setTimeout(() => {
                            document.getElementById("settingsFeedback").style.display = "none";
                        }, 3000);
                    } catch (error) {
                        console.error("Error setting refresh interval:", error);
                        appendDebugLog(`Error setting refresh interval: ${error}`);
                        document.getElementById("settingsFeedback").textContent = "Failed to set refresh interval.";
                        document.getElementById("settingsFeedback").style.display = "block";
                        setTimeout(() => {
                            document.getElementById("settingsFeedback").style.display = "none";
                        }, 3000);
                    }
                });
            });

            console.log("Refresh interval buttons initialized.");
            appendDebugLog("Refresh interval buttons initialized.");
        }

        // Function to Initialize Visible Columns on Page Load
        async function initializeVisibleColumns() {
            const db = await openDatabase();
            const store = db.transaction(settingsStoreName, "readonly").objectStore(settingsStoreName);
            const savedColumns = await new Promise((resolve, reject) => {
                const request = store.get("visibleColumns");
                request.onsuccess = (event) => resolve(event.target.result?.value || []);
                request.onerror = (event) => reject(event.target.error);
            });

            if (savedColumns.length > 0) {
                visibleColumns = savedColumns;
                // Ensure uniqueness
                visibleColumns = [...new Set(visibleColumns)];

                console.log("Loaded visibleColumns from settings:", visibleColumns);
                appendDebugLog("Loaded visibleColumns from settings.");
            }
        }

        // Function to Fetch All Unique Tickers from IndexedDB
        async function fetchAllTickers() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index.openCursor(null, "nextunique");
                const tickers = [];
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        tickers.push(cursor.key);
                        cursor.continue();
                    } else {
                        resolve(tickers);
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Generate Filter Checkboxes
        async function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            const db = await openDatabase();
            const store = db.transaction(positionsStoreName, "readonly").objectStore(positionsStoreName);

            for (const ticker of uniqueTickers) {
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" checked>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                // Determine the initial checked state based on positions' hide attribute
                const request = store.index && store.index("tickerSymbol") ? store.index("tickerSymbol").getAll(ticker) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === ticker);
                    const isHidden = positions.every(pos => pos.hide); // Changed to 'every' for correct logic
                    if (isHidden) {
                        checkbox.querySelector('input').checked = false;
                    } else {
                        checkbox.querySelector('input').checked = true;
                    }
                };
                request.onerror = (event) => {
                    console.error(`Error fetching positions for ${ticker}:`, event.target.error);
                };

                // Add Event Listener for Checkbox Change
                checkbox.querySelector('input').addEventListener("change", async () => {
                    const ticker = checkbox.querySelector("input").value;
                    const isChecked = checkbox.querySelector("input").checked;
                    const hide = !isChecked;

                    // Update the 'hide' attribute for all positions with this tickerSymbol
                    try {
                        await setHideForTickerSymbol(ticker, hide);
                        console.log(`Set hide=${hide} for tickerSymbol=${ticker}`);
                        appendDebugLog(`Set hide=${hide} for tickerSymbol=${ticker}`);

                        // Reload portfolio after updating hide status
                        await loadPortfolio();
                    } catch (error) {
                        console.error(`Error setting hide for tickerSymbol=${ticker}:`, error);
                        appendDebugLog(`Error setting hide for tickerSymbol=${ticker}: ${error}`);
                    }
                });

                filterCheckboxes.appendChild(checkbox);
            }
        }

        // Function to Update the 'hide' Attribute for All Positions with a Specific Ticker Symbol
        async function setHideForTickerSymbol(tickerSymbol, hide) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index ? index.getAll(tickerSymbol) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === tickerSymbol);
                    for (const position of positions) {
                        position.hide = hide;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    resolve();
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Start Auto-Refresh
        async function startAutoRefresh() {
            const interval = await getRefreshInterval();
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }

            if (interval > 0) {
                refreshIntervalId = setInterval(async () => {
                    console.log("Auto-refreshing prices...");
                    appendDebugLog("Auto-refreshing prices...");
                    await loadPortfolio();
                }, interval * 1000);
                console.log(`Auto-refresh set to every ${interval} seconds.`);
                appendDebugLog(`Auto-refresh set to every ${interval} seconds.`);
            } else {
                console.log("Auto-refresh stopped.");
                appendDebugLog("Auto-refresh stopped.");
            }
        }

        // Function to Get Refresh Interval from IndexedDB
        async function getRefreshInterval() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Initialize Visible Columns on Page Load
        async function initializeVisibleColumns() {
            const db = await openDatabase();
            const store = db.transaction(settingsStoreName, "readonly").objectStore(settingsStoreName);
            const savedColumns = await new Promise((resolve, reject) => {
                const request = store.get("visibleColumns");
                request.onsuccess = (event) => resolve(event.target.result?.value || []);
                request.onerror = (event) => reject(event.target.error);
            });

            if (savedColumns.length > 0) {
                visibleColumns = savedColumns;
                // Ensure uniqueness
                visibleColumns = [...new Set(visibleColumns)];

                console.log("Loaded visibleColumns from settings:", visibleColumns);
                appendDebugLog("Loaded visibleColumns from settings.");
            }
        }

        // Function to Open IndexedDB
        async function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 2);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(positionsStoreName)) {
                        const positionsStore = db.createObjectStore(positionsStoreName, { keyPath: "id", autoIncrement: true });
                        positionsStore.createIndex("tickerSymbol", "tickerSymbol", { unique: false });
                        appendDebugLog("Created 'Positions' object store with 'tickerSymbol' index.");
                    }

                    if (!db.objectStoreNames.contains(settingsStoreName)) {
                        db.createObjectStore(settingsStoreName, { keyPath: "key" });
                        appendDebugLog("Created 'Settings' object store.");
                    }
                };

                request.onsuccess = (event) => {
                    const db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    appendDebugLog(`Database open failed: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        // Function to Fetch Visible Positions from IndexedDB
        async function fetchVisiblePositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => {
                    const all = event.target.result;
                    // Filter out positions where hide is true
                    const visible = all.filter(position => !position.hide);
                    resolve(visible);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Sort Positions
        function sortPositions() {
            if (!sortColumn) return; // No sorting applied

            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                // Handle undefined or null values
                valA = valA !== undefined && valA !== null ? valA : "";
                valB = valB !== undefined && valB !== null ? valB : "";

                if (typeof valA === "string") {
                    valA = valA.toLowerCase();
                }
                if (typeof valB === "string") {
                    valB = valB.toLowerCase();
                }

                if (valA < valB) {
                    return sortDirection === 'asc' ? -1 : 1;
                }
                if (valA > valB) {
                    return sortDirection === 'asc' ? 1 : -1;
                }
                return 0;
            });
        }

        // Function to Initialize Everything on DOMContentLoaded
        document.addEventListener("DOMContentLoaded", async () => {
            await initializeVisibleColumns(); // Load saved column order first
            populateSortableColumns();        // Then populate the "Customize Columns" list based on saved order
            await loadPortfolio();
            await initializeRefreshIntervalButtons();
            await startAutoRefresh();
        });

        // Reset Settings Button Functionality
        document.getElementById("resetSettings").addEventListener("click", async () => {
            // Reset visibleColumns to default
            visibleColumns = availableColumns.map(col => col.key);
            
            // Save to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "visibleColumns", value: visibleColumns });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
                appendDebugLog("Visible columns reset to default in settings.");
            } catch (error) {
                console.error("Error resetting visible columns:", error);
                appendDebugLog(`Error resetting visible columns: ${error}`);
            }

            // Reset hide attribute for all positions
            const db2 = await openDatabase();
            const transaction2 = db2.transaction(positionsStoreName, "readwrite");
            const store2 = transaction2.objectStore(positionsStoreName);
            const getAllRequest = store2.getAll();

            getAllRequest.onsuccess = async (event) => {
                const positions = event.target.result;
                for (const position of positions) {
                    position.hide = false;
                    const updateRequest = store2.put(position);
                    await new Promise((res, rej) => {
                        updateRequest.onsuccess = () => res();
                        updateRequest.onerror = (e) => rej(e.target.error);
                    });
                }
                appendDebugLog("All positions set to visible.");
                await loadPortfolio();
            };

            getAllRequest.onerror = (event) => {
                console.error("Error resetting positions' hide attributes:", event.target.error);
                appendDebugLog(`Error resetting positions' hide attributes: ${event.target.error}`);
            };

            // Update UI
            populateSortableColumns();
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);

            // Provide user feedback
            document.getElementById("settingsFeedback").textContent = "Settings reset to default.";
            document.getElementById("settingsFeedback").style.display = "block";
            setTimeout(() => {
                document.getElementById("settingsFeedback").style.display = "none";
            }, 3000);
        });
    </script>
</body>
</html>