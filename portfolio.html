<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            display: none;
            margin-top: 20px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #666;
        }
        .th-name {
            margin-left: 20px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
        /* Debug Logs Styling */
        #debugLogs {
            background-color: #1e1e1e;
            padding: 10px;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <div class="container">
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr>
                        <th data-column="tickerSymbol" data-sort-type="string" data-sort-key="tickerSymbol" data-col-index="0">
                            <span class="th-name">Ticker</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="avgPrice" data-sort-type="number" data-sort-key="avgPrice" data-col-index="1">
                            <span class="th-name">Average Price</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="numShares" data-sort-type="number" data-sort-key="numShares" data-col-index="2">
                            <span class="th-name">Shares</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="lastPrice" data-sort-type="number" data-sort-key="lastPrice" data-col-index="3">
                            <span class="th-name">Current Price</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="costBasis" data-sort-type="number" data-sort-key="costBasis" data-col-index="4">
                            <span class="th-name">Cost Basis</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="totalValue" data-sort-type="number" data-sort-key="totalValue" data-col-index="5">
                            <span class="th-name">Total Value</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="profit" data-sort-type="number" data-sort-key="profit" data-col-index="6">
                            <span class="th-name">Profit</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="profitPct" data-sort-type="number" data-sort-key="profitPct" data-col-index="7">
                            <span class="th-name">Profit %</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="changeToday" data-sort-type="number" data-sort-key="changeToday" data-col-index="8">
                            <span class="th-name">Change Today</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="changePctToday" data-sort-type="number" data-sort-key="changePctToday" data-col-index="9">
                            <span class="th-name">Change % Today</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="gapPct" data-sort-type="number" data-sort-key="gapPct" data-col-index="10">
                            <span class="th-name">Gap %</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                        <th data-column="lastTime" data-sort-type="string" data-sort-key="lastTime" data-col-index="11">
                            <span class="th-name">Time Since Last Trade</span>
                            <span class="sort-arrow asc">▲</span>
                            <span class="sort-arrow desc">▼</span>
                        </th>
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row">
                        <td>Totals</td>
                        <td colspan="3"></td>
                        <td id="totalCostBasis">0.00</td>
                        <td id="totalValue">0.00</td>
                        <td id="totalProfit">0.00</td>
                        <td id="totalProfitPct">0.00%</td>
                        <td id="totalChangeToday">0.00</td>
                        <td id="totalChangePctToday">0.00%</td>
                        <td id="totalGapPct">0.00%</td>
                        <td></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>
        <div class="settings-toggle text-right">
            <span id="settingsIcon">⚙️ Settings</span>
        </div>
        <div class="settings" id="settings">
            <h3>Settings</h3>
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" style="list-style-type: none; padding: 0;">
                    <li class="column-item" data-column="tickerSymbol">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-tickerSymbol" value="tickerSymbol" checked>
                        <label class="form-check-label text-light" for="checkbox-tickerSymbol">Ticker</label>
                    </li>
                    <li class="column-item" data-column="avgPrice">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-avgPrice" value="avgPrice" checked>
                        <label class="form-check-label text-light" for="checkbox-avgPrice">Average Price</label>
                    </li>
                    <li class="column-item" data-column="numShares">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-numShares" value="numShares" checked>
                        <label class="form-check-label text-light" for="checkbox-numShares">Shares</label>
                    </li>
                    <li class="column-item" data-column="lastPrice">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-lastPrice" value="lastPrice" checked>
                        <label class="form-check-label text-light" for="checkbox-lastPrice">Current Price</label>
                    </li>
                    <li class="column-item" data-column="costBasis">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-costBasis" value="costBasis" checked>
                        <label class="form-check-label text-light" for="checkbox-costBasis">Cost Basis</label>
                    </li>
                    <li class="column-item" data-column="totalValue">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-totalValue" value="totalValue" checked>
                        <label class="form-check-label text-light" for="checkbox-totalValue">Total Value</label>
                    </li>
                    <li class="column-item" data-column="profit">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-profit" value="profit" checked>
                        <label class="form-check-label text-light" for="checkbox-profit">Profit</label>
                    </li>
                    <li class="column-item" data-column="profitPct">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-profitPct" value="profitPct" checked>
                        <label class="form-check-label text-light" for="checkbox-profitPct">Profit %</label>
                    </li>
                    <li class="column-item" data-column="changeToday">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-changeToday" value="changeToday" checked>
                        <label class="form-check-label text-light" for="checkbox-changeToday">Change Today</label>
                    </li>
                    <li class="column-item" data-column="changePctToday">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-changePctToday" value="changePctToday" checked>
                        <label class="form-check-label text-light" for="checkbox-changePctToday">Change % Today</label>
                    </li>
                    <li class="column-item" data-column="gapPct">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-gapPct" value="gapPct" checked>
                        <label class="form-check-label text-light" for="checkbox-gapPct">Gap %</label>
                    </li>
                    <li class="column-item" data-column="lastTime">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-lastTime" value="lastTime" checked>
                        <label class="form-check-label text-light" for="checkbox-lastTime">Time Since Last Trade</label>
                    </li>
                </ul>
            </div>
            <label for="alpacaApiKey">Alpaca API Key:</label>
            <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            <label for="alpacaApiSecret" class="mt-2">Alpaca API Secret:</label>
            <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            <label for="apiKeyInput" class="mt-2">Finnhub API Key:</label>
            <input type="text" id="apiKeyInput" class="form-control" placeholder="Enter your Finnhub API Key">
            <button id="saveKeys" class="btn btn-primary mt-2">Save Settings</button>
        </div>
        <!-- Debug Logs Section (Optional) -->
        <div id="debugLogs"></div>
    </div>

    <script>
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let selectedTickers = [];
        let visibleColumns = [
            "tickerSymbol",
            "avgPrice",
            "numShares",
            "lastPrice",
            "costBasis",
            "totalValue",
            "profit",
            "profitPct",
            "changeToday",
            "changePctToday",
            "gapPct",
            "lastTime"
        ];

        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            const alpacaKey = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_KEY_ID");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            const alpacaSecret = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_SECRET_KEY");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (alpacaKey && alpacaSecret) {
                return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
            }

            console.warn("Alpaca credentials not available, falling back to Finnhub.");
            const finnhubKey = await new Promise((resolve, reject) => {
                const request = store.get("finnhubApiKey");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (!finnhubKey) {
                console.error("Finnhub API Key is not set. Please configure it in the settings.");
                return {};
            }

            return await fetchPricesFromFinnhub(tickers, finnhubKey);
        }

        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                for (const [symbol, snapshot] of Object.entries(data)) {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t || "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };
                }

                console.log("Fetched prices from Alpaca:", prices);
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                return {};
            }
        }

        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                return {};
            }
        }

        async function loadPortfolio() {
            allPositions = await fetchPositions();
            // Calculate and append additional fields to each position
            allPositions = allPositions.map(position => {
                const currentPrice = position.lastPrice || 0;
                const costBasis = position.avgPrice * position.numShares;
                const totalValue = currentPrice * position.numShares;
                const profit = totalValue - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = position.changeToday || 0;
                const changePctToday = position.changePctToday || 0;
                const gapPct = position.gapPct || 0;
                const timeSinceLastTrade = position.lastTime || "N/A";

                return {
                    ...position,
                    costBasis,
                    totalValue,
                    profit,
                    profitPct,
                    changeToday,
                    changePctToday,
                    gapPct,
                    timeSinceLastTrade
                };
            });

            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            selectedTickers = selectedTickers.length === 0 ? uniqueTickers : selectedTickers;
            generateFilterCheckboxes(uniqueTickers);
            sortPositions(); // Sort after adding calculated fields
            renderPortfolio();
        }

        async function renderPortfolio() {
            const filteredPositions = filterPositions(allPositions, selectedTickers);
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            if (filteredPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="12" class="text-center">No positions to display.</td></tr>`;
                return;
            }

            // Collect all unique tickers
            const uniqueTickers = [...new Set(filteredPositions.map((p) => p.tickerSymbol))];

            // Fetch batched prices for all symbols
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totalCostBasis = 0;
            let totalValue = 0;
            let totalProfit = 0;
            let totalProfitPct = 0;
            let totalChangeToday = 0;
            let totalChangePctToday = 0;
            let totalGapPct = 0;

            filteredPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totalCostBasis += position.costBasis;
                totalValue += position.totalValue;
                totalProfit += position.profit;
                totalProfitPct += position.profitPct;
                totalChangeToday += position.changeToday;
                totalChangePctToday += position.changePctToday;
                totalGapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                const row = `
                    <tr>
                        <td>${position.tickerSymbol}</td>
                        <td>${position.avgPrice.toFixed(2)}</td>
                        <td>${position.numShares}</td>
                        <td>${currentPrice.toFixed(2)}</td>
                        <td>${position.costBasis.toFixed(2)}</td>
                        <td>${position.totalValue.toFixed(2)}</td>
                        <td class="${profitClass}">${position.profit.toFixed(2)}</td>
                        <td>${position.profitPct.toFixed(2)}%</td>
                        <td>${position.changeToday.toFixed(2)}</td>
                        <td>${position.changePctToday.toFixed(2)}%</td>
                        <td>${position.gapPct.toFixed(2)}%</td>
                        <td>${position.timeSinceLastTrade}</td>
                    </tr>
                `;
                portfolioBody.innerHTML += row;
            });

            // Calculate average profit percentage
            const averageProfitPct = filteredPositions.length > 0 ? (totalProfitPct / filteredPositions.length) : 0;

            // Calculate total profit percentage based on total cost basis
            totalProfitPct = totalCostBasis !== 0 ? (totalProfit / totalCostBasis) * 100 : 0;

            // Update totals in the footer
            document.getElementById("totalCostBasis").textContent = totalCostBasis.toFixed(2);
            document.getElementById("totalValue").textContent = totalValue.toFixed(2);
            document.getElementById("totalProfit").textContent = totalProfit.toFixed(2);
            document.getElementById("totalProfitPct").textContent = totalProfitPct.toFixed(2) + "%";
            document.getElementById("totalChangeToday").textContent = totalChangeToday.toFixed(2);
            document.getElementById("totalChangePctToday").textContent = totalChangePctToday.toFixed(2) + "%";
            document.getElementById("totalGapPct").textContent = totalGapPct.toFixed(2) + "%";
        }

        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        async function fetchPositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        async function updatePosition(tickerSymbol, currentPrice, lastTime, openPrice, prevClosePrice) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);

            const position = await new Promise((resolve, reject) => {
                const request = store.get(tickerSymbol);
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });

            if (position) {
                position.lastPrice = currentPrice;
                position.lastTime = lastTime;
                position.openPrice = openPrice;
                position.prevClosePrice = prevClosePrice;
                store.put(position);
            }
        }

        async function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 2);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(positionsStoreName)) {
                        db.createObjectStore(positionsStoreName, { keyPath: "tickerSymbol" });
                        appendDebugLog("Created 'Positions' object store.");
                    }

                    if (!db.objectStoreNames.contains(settingsStoreName)) {
                        db.createObjectStore(settingsStoreName, { keyPath: "key" });
                        appendDebugLog("Created 'Settings' object store.");
                    }
                };

                request.onsuccess = (event) => {
                    const db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    appendDebugLog(`Database open failed: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        async function startAutoRefresh() {
            const interval = await getRefreshInterval();
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }

            if (interval > 0) {
                refreshIntervalId = setInterval(async () => {
                    console.log("Auto-refreshing prices...");
                    await loadPortfolio(); // Changed to loadPortfolio to recalculate and sort
                }, interval * 1000);
            }
        }

        async function getRefreshInterval() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            uniqueTickers.forEach((ticker) => {
                const isChecked = selectedTickers.includes(ticker);
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" ${isChecked ? "checked" : ""}>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                checkbox.addEventListener("change", () => {
                    const ticker = checkbox.querySelector("input").value;
                    if (checkbox.querySelector("input").checked) {
                        if (!selectedTickers.includes(ticker)) {
                            selectedTickers.push(ticker);
                        }
                    } else {
                        selectedTickers = selectedTickers.filter((t) => t !== ticker);
                    }
                    sortPositions(); // Re-sort after filter change
                    renderPortfolio();
                });

                filterCheckboxes.appendChild(checkbox);
            });
        }

        function filterPositions(positions, selectedTickers) {
            const filterInput = document.getElementById("filterInput");
            const filterText = filterInput.value.toLowerCase();
            return positions.filter((position) => {
                const tickerMatches = position.tickerSymbol.toLowerCase().includes(filterText);
                const isSelected = selectedTickers.includes(position.tickerSymbol);
                return tickerMatches && isSelected;
            });
        }

        document.addEventListener("DOMContentLoaded", async () => {
            const settingsIcon = document.getElementById("settingsIcon");
            const settingsSection = document.getElementById("settings");

            settingsIcon.addEventListener("click", () => {
                if (settingsSection.style.display === "none" || !settingsSection.style.display) {
                    settingsSection.style.display = "block";
                } else {
                    settingsSection.style.display = "none";
                }
            });

            const refreshButtons = document.querySelectorAll(".refresh-interval-button");

            refreshButtons.forEach((button) => {
                button.addEventListener("click", async (event) => {
                    const selectedInterval = parseInt(event.target.getAttribute("data-interval"));
                    await saveRefreshInterval(selectedInterval);

                    refreshButtons.forEach((btn) => btn.classList.remove("btn-primary"));
                    event.target.classList.add("btn-primary");

                    startAutoRefresh();
                });
            });

            const saveKeysButton = document.getElementById("saveKeys");
            saveKeysButton.addEventListener("click", async () => {
                const alpacaKey = document.getElementById("alpacaApiKey").value;
                const alpacaSecret = document.getElementById("alpacaApiSecret").value;
                const finnhubKey = document.getElementById("apiKeyInput").value;

                try {
                    await saveKeys(alpacaKey, alpacaSecret, finnhubKey);
                    showFeedback("Settings saved successfully!", "success");
                } catch (error) {
                    console.error("Failed to save settings:", error);
                    showFeedback("Failed to save settings.", "danger");
                }
            });

            const tableHeaders = document.querySelectorAll("#portfolioTable thead th");

            tableHeaders.forEach((header) => {
                header.addEventListener("click", (event) => {
                    const newSortColumn = header.getAttribute("data-sort-key");
                    const sortType = header.getAttribute("data-sort-type");

                    if (sortColumn === newSortColumn) {
                        sortDirection = sortDirection === "asc" ? "desc" : "asc";
                    } else {
                        sortColumn = newSortColumn;
                        sortDirection = "asc";
                    }

                    tableHeaders.forEach((h) => {
                        h.classList.remove("sorted-asc", "sorted-desc");
                    });
                    header.classList.add(sortDirection === "asc" ? "sorted-asc" : "sorted-desc");

                    sortPositions();
                    renderPortfolio();
                });
            });

            const filterInput = document.getElementById("filterInput");
            filterInput.addEventListener("input", () => {
                sortPositions(); // Re-sort when filter changes
                renderPortfolio();
            });

            await loadSavedVisibleColumns();
            await loadSavedRefreshInterval();
            await loadPortfolio();
            await startAutoRefresh();
            setupColumnCustomization();
        });

        async function saveKeys(alpacaKey, alpacaSecret, finnhubKey) {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);

            appendDebugLog("Saving API keys...");

            if (alpacaKey) {
                store.put({ key: "APCA_API_KEY_ID", value: alpacaKey });
                appendDebugLog(`Alpaca Key saved: ${alpacaKey}`);
            }

            if (alpacaSecret) {
                store.put({ key: "APCA_API_SECRET_KEY", value: alpacaSecret });
                appendDebugLog("Alpaca Secret saved.");
            }

            if (finnhubKey) {
                store.put({ key: "finnhubApiKey", value: finnhubKey });
                appendDebugLog("Finnhub Key saved.");
            }

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    appendDebugLog("Settings saved successfully.");
                    resolve();
                };

                transaction.onerror = (event) => {
                    appendDebugLog(`Failed to save settings: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        function showFeedback(message, type) {
            const feedbackDiv = document.getElementById("settingsFeedback");
            feedbackDiv.textContent = message;
            feedbackDiv.className = `mt-2 text-${type}`;
            feedbackDiv.style.display = "block";

            setTimeout(() => {
                feedbackDiv.style.display = "none";
            }, 3000);
        }

        async function saveRefreshInterval(interval) {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);

            store.put({ key: "refreshInterval", value: interval });

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    console.log("Refresh interval saved successfully!");
                    resolve();
                };
                transaction.onerror = (event) => {
                    console.error("Failed to save refresh interval.", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadSavedRefreshInterval() {
            const interval = await getRefreshInterval();
            const refreshButtons = document.querySelectorAll(".refresh-interval-button");

            refreshButtons.forEach((button) => {
                if (parseInt(button.getAttribute("data-interval")) === interval) {
                    button.classList.add("btn-primary");
                } else {
                    button.classList.remove("btn-primary");
                }
            });
        }

        function appendDebugLog(message) {
            const debugDiv = document.getElementById("debugLogs");
            const log = document.createElement("div");
            log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugDiv.appendChild(log);
            debugDiv.style.display = "block"; // Make sure it's visible if needed
        }

        function setupColumnCustomization() {
            const sortableColumns = document.getElementById("sortableColumns");
            const columnCheckboxes = document.querySelectorAll("#columnCustomization .column-checkbox");
            const columnItems = document.querySelectorAll("#sortableColumns .column-item");

            let draggedItem = null;

            sortableColumns.addEventListener("dragstart", (event) => {
                draggedItem = event.target;
                event.dataTransfer.effectAllowed = "move";
                event.dataTransfer.setData("text/plain", "");
                setTimeout(() => {
                    draggedItem.style.opacity = "0.5";
                }, 0);
            });

            sortableColumns.addEventListener("dragover", (event) => {
                event.preventDefault();
                const targetItem = event.target.closest(".column-item");
                if (targetItem) {
                    const bounding = targetItem.getBoundingClientRect();
                    const offset = bounding.y + bounding.height / 2;

                    if (event.clientY - offset > 0) {
                        targetItem.style.borderBottom = "2px solid white";
                        targetItem.style.borderTop = "";
                    } else {
                        targetItem.style.borderTop = "2px solid white";
                        targetItem.style.borderBottom = "";
                    }
                }
            });

            sortableColumns.addEventListener("dragleave", (event) => {
                const targetItem = event.target.closest(".column-item");
                if (targetItem) {
                    targetItem.style.borderTop = "";
                    targetItem.style.borderBottom = "";
                }
            });

            sortableColumns.addEventListener("drop", async (event) => {
                event.preventDefault();
                const targetItem = event.target.closest(".column-item");
                if (draggedItem && targetItem) {
                    if (draggedItem !== targetItem) {
                        if (targetItem.style.borderBottom === "2px solid white") {
                            sortableColumns.insertBefore(draggedItem, targetItem.nextSibling);
                        } else {
                            sortableColumns.insertBefore(draggedItem, targetItem);
                        }
                        await updateVisibleColumns();
                        updateTableColumns();
                        renderPortfolio();
                    }
                    targetItem.style.borderTop = "";
                    targetItem.style.borderBottom = "";
                    draggedItem.style.opacity = "";
                    draggedItem = null;
                }
            });

            columnCheckboxes.forEach((checkbox) => {
                checkbox.addEventListener("change", async () => {
                    const columnKey = checkbox.value;
                    if (checkbox.checked) {
                        if (!visibleColumns.includes(columnKey)) {
                            visibleColumns.push(columnKey);
                        }
                    } else {
                        visibleColumns = visibleColumns.filter((key) => key !== columnKey);
                    }
                    await saveVisibleColumns();
                    updateTableColumns();
                    renderPortfolio();
                });
            });
        }

        async function saveVisibleColumns() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);
            const sortedColumnItems = document.querySelectorAll("#sortableColumns .column-item");
            const updatedVisibleColumns = Array.from(sortedColumnItems)
                .map(item => item.getAttribute("data-column"))
                .filter(column => visibleColumns.includes(column));

            store.put({ key: "visibleColumns", value: updatedVisibleColumns });

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    console.log("Visible columns saved successfully!");
                    resolve();
                };
                transaction.onerror = (event) => {
                    console.error("Failed to save visible columns.", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadSavedVisibleColumns() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("visibleColumns");
                request.onsuccess = (event) => {
                    const savedVisibleColumns = event.target.result?.value;
                    if (savedVisibleColumns) {
                        visibleColumns = savedVisibleColumns;
                        updateCheckboxes();
                    }
                    resolve();
                };
                request.onerror = (event) => {
                    console.error("Failed to load visible columns.", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function updateCheckboxes() {
            const columnCheckboxes = document.querySelectorAll("#sortableColumns .column-checkbox");
            const columnItems = document.querySelectorAll("#sortableColumns .column-item");

            columnCheckboxes.forEach((checkbox) => {
                checkbox.checked = visibleColumns.includes(checkbox.value);
            });

            const sortableColumns = document.getElementById("sortableColumns");
            visibleColumns.forEach(columnKey => {
                const columnItem = Array.from(columnItems).find(item => item.getAttribute("data-column") === columnKey);
                if (columnItem) {
                    sortableColumns.appendChild(columnItem);
                }
            });
        }

        function updateTableColumns() {
            const tableHeaders = document.querySelectorAll("#portfolioTable thead th");
            const bodyRows = document.querySelectorAll("#portfolioTable tbody tr");
            const footerRow = document.querySelector("#portfolioTable tfoot tr");
            const footerCells = footerRow.querySelectorAll("td");
            const headerMap = {};

            tableHeaders.forEach(header => {
                const headerKey = header.getAttribute("data-sort-key");
                headerMap[headerKey] = header;
            });

            tableHeaders.forEach(header => {
                const headerKey = header.getAttribute("data-sort-key");
                header.style.display = visibleColumns.includes(headerKey) ? "" : "none";
            });

            bodyRows.forEach(row => {
                const cells = row.querySelectorAll("td");
                cells.forEach((cell, index) => {
                    const headerKey = tableHeaders[index].getAttribute("data-sort-key");
                    if (headerKey) {
                        cell.style.display = visibleColumns.includes(headerKey) ? "" : "none";
                    }
                });
            });

            footerCells.forEach((cell, index) => {
                if (index > 0 && index <= tableHeaders.length) {
                    const headerKey = tableHeaders[index - 1].getAttribute("data-sort-key");
                    cell.style.display = visibleColumns.includes(headerKey) ? "" : "none";
                }
            });
        }

        async function updateVisibleColumns() {
            const columnItems = document.querySelectorAll("#sortableColumns .column-item");
            const newVisibleColumns = [];

            columnItems.forEach(item => {
                const columnKey = item.getAttribute("data-column");
                if (visibleColumns.includes(columnKey)) {
                    newVisibleColumns.push(columnKey);
                }
            });

            visibleColumns = newVisibleColumns;
            await saveVisibleColumns();
        }

        function sortPositions() {
            if (!sortColumn) return;

            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                // Handle undefined or null values
                valA = valA !== undefined && valA !== null ? valA : (typeof valB === 'number' ? -Infinity : '');
                valB = valB !== undefined && valB !== null ? valB : (typeof valA === 'number' ? -Infinity : '');

                // If sorting by string, convert to lowercase for case-insensitive comparison
                if (typeof valA === 'string') {
                    valA = valA.toLowerCase();
                    valB = typeof valB === 'string' ? valB.toLowerCase() : '';
                }

                if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });
        }

        async function loadSavedVisibleColumns() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("visibleColumns");
                request.onsuccess = (event) => {
                    const savedVisibleColumns = event.target.result?.value;
                    if (savedVisibleColumns) {
                        visibleColumns = savedVisibleColumns;
                        updateCheckboxes();
                    }
                    resolve();
                };
                request.onerror = (event) => {
                    console.error("Failed to load visible columns.", event.target.error);
                    reject(event.target.error);
                };
            });
        }

    </script>
</body>
</html>