<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            display: none;
            margin-top: 20px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #666;
        }
        .th-name {
            margin-left: 20px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <div class="container">
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr>
                        <!-- Draggable handles are added inside the th elements -->
                        <th data-sort-type="string" data-sort-key="tickerSymbol" data-col-index="0"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Ticker</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="avgPrice" data-col-index="1"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Average Price</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="numShares" data-col-index="2"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Shares</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="lastPrice" data-col-index="3"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Current Price</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="costBasis" data-col-index="4"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Cost Basis</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="totalValue" data-col-index="5"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Total Value</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="profit" data-col-index="6"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Profit</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="profitPct" data-col-index="7"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Profit %</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="changeToday" data-col-index="8"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Change Today</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="number" data-sort-key="changePctToday" data-col-index="9"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Change % Today</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-sort-type="string" data-sort-key="lastTime" data-col-index="10"><div class="drag-handle"><i class="fas fa-grip-vertical"></i></div><span class="th-name">Time Since Last Trade</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row">
                        <td>Totals</td>
                        <td colspan="3"></td>
                        <td id="totalCostBasis">0.00</td>
                        <td id="totalValue">0.00</td>
                        <td id="totalProfit">0.00</td>
                        <td id="totalProfitPct">0.00</td>
                        <td id="totalChangeToday">0.00</td>
                        <td id="totalChangePctToday">0.00</td>
                        <td></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>
        <div class="settings-toggle text-right">
            <span id="settingsIcon">⚙️ Settings</span>
        </div>
        <div class="settings" id="settings">
            <h3>Settings</h3>
            <label for="alpacaApiKey">Alpaca API Key:</label>
            <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            <label for="alpacaApiSecret" class="mt-2">Alpaca API Secret:</label>
            <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            <label for="apiKeyInput" class="mt-2">Finnhub API Key:</label>
            <input type="text" id="apiKeyInput" class="form-control" placeholder="Enter your Finnhub API Key">
            <button id="saveKeys" class="btn btn-primary mt-2">Save Settings</button>
        </div>
    </div>

    <script>
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let selectedTickers = [];

        async function fetchCurrentPrices(tickers) {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            const alpacaKey = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_KEY_ID");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            const alpacaSecret = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_SECRET_KEY");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (alpacaKey && alpacaSecret) {
                return fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
            }

            console.warn("Alpaca credentials not available, falling back to Finnhub.");
            const finnhubKey = await new Promise((resolve, reject) => {
                const request = store.get("finnhubApiKey");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (!finnhubKey) {
                console.error("Finnhub API Key is not set. Please configure it in the settings.");
                return {};
            }

            return fetchPricesFromFinnhub(tickers, finnhubKey);
        }

        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    return {};
                }

                const data = await response.json();
                const prices = {};
                Object.entries(data).forEach(([symbol, snapshot]) => {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t || "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0
                    };
                });
                console.log("Fetched prices from Alpaca:", prices);
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                return {};
            }
        }

        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                return {};
            }
        }

        async function loadPortfolio() {
            allPositions = await fetchPositions();
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            selectedTickers = selectedTickers.length === 0 ? uniqueTickers : selectedTickers;
            generateFilterCheckboxes(uniqueTickers);
            renderPortfolio();
        }

        function renderPortfolio() {
            const filteredPositions = filterPositions(allPositions, selectedTickers);
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            let totalCostBasis = 0;
            let totalValue = 0;
            let totalProfit = 0;
            let totalProfitPct = 0;
            let totalChangeToday = 0;
            let totalChangePctToday = 0;

            const pricedPositions = filteredPositions.map(async (position) => {
                const priceData = await fetchCurrentPrices([position.tickerSymbol]);
                const currentPrice = priceData[position.tickerSymbol]?.price || position.lastPrice || 0;
                const lastTime = priceData[position.tickerSymbol]?.time || position.lastTime || "N/A";
                const openPrice = priceData[position.tickerSymbol]?.open || 0;
                const prevClosePrice = priceData[position.tickerSymbol]?.prevClose || 0;

                if (currentPrice > 0) {
                    await updatePosition(position.tickerSymbol, currentPrice, lastTime, openPrice);
                    position.lastPrice = currentPrice;
                    position.lastTime = lastTime;
                    position.openPrice = openPrice;
                    position.prevClosePrice = prevClosePrice;
                }

                const costBasis = position.avgPrice * position.numShares;
                const totalValueForPosition = currentPrice * position.numShares;
                const profit = totalValueForPosition - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = currentPrice - position.openPrice;
                const changePctToday = position.openPrice !== 0 ? ((currentPrice - position.openPrice) / position.openPrice) * 100 : 0;

                totalCostBasis += costBasis;
                totalValue += totalValueForPosition;
                totalProfit += profit;

                return { ...position, costBasis, totalValue: totalValueForPosition, profit, profitPct, changeToday, changePctToday };
            });

            Promise.all(pricedPositions).then((positionsWithValues) => {
                totalProfitPct = totalCostBasis !== 0 ? (totalProfit / totalCostBasis) * 100 : 0;

                positionsWithValues.forEach((position) => {
                    const { tickerSymbol, avgPrice, numShares, lastPrice, costBasis, totalValue, profit, profitPct, changeToday, changePctToday, lastTime } = position;
                    const profitClass = profit >= 0 ? "profit-positive" : "profit-negative";
                    const changeTodayClass = changeToday >= 0 ? "profit-positive" : "profit-negative";
                    const changePctTodayClass = changePctToday >= 0 ? "profit-positive" : "profit-negative";
                    const timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                    const row = `
                        <tr>
                            <td><a href="./?symbol=${tickerSymbol}" class="text-decoration-none text-light">${tickerSymbol}</a></td>
                            <td>${avgPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td>${numShares.toLocaleString()}</td>
                            <td>${lastPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td>${costBasis.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td>${totalValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td class="${profitClass}">${profit.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td class="${profitClass}">${profitPct.toFixed(2)}%</td>
                            <td class="${changeTodayClass}">${changeToday.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td class="${changePctTodayClass}">${changePctToday.toFixed(2)}%</td>
                            <td>${timeSinceLastTrade}</td>
                        </tr>
                    `;
                    portfolioBody.innerHTML += row;
                });

                document.getElementById("totalCostBasis").textContent = totalCostBasis.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalValue").textContent = totalValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalProfit").textContent = totalProfit.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalProfitPct").textContent = totalProfitPct.toFixed(2) + "%";
                document.getElementById("totalChangeToday").textContent = totalChangeToday.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalChangePctToday").textContent = totalChangePctToday.toFixed(2) + "%";
            });
        }

        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        async function fetchPositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        async function updatePosition(tickerSymbol, currentPrice, lastTime, openPrice, prevClosePrice) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);

            const position = await new Promise((resolve, reject) => {
                const request = store.get(tickerSymbol);
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });

            if (position) {
                position.lastPrice = currentPrice;
                position.lastTime = lastTime;
                position.openPrice = openPrice;
                position.prevClosePrice = prevClosePrice;
                store.put(position);
            }
        }

        async function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 2);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(positionsStoreName)) {
                        db.createObjectStore(positionsStoreName, { keyPath: "tickerSymbol" });
                        appendDebugLog("Created 'Positions' object store.");
                    }

                    if (!db.objectStoreNames.contains(settingsStoreName)) {
                        db.createObjectStore(settingsStoreName, { keyPath: "key" });
                        appendDebugLog("Created 'Settings' object store.");
                    }
                };

                request.onsuccess = (event) => {
                    const db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    appendDebugLog(`Database open failed: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        async function startAutoRefresh() {
            const interval = await getRefreshInterval();
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }

            if (interval > 0) {
                refreshIntervalId = setInterval(async () => {
                    console.log("Auto-refreshing prices...");
                    await renderPortfolio();
                }, interval * 1000);
            }
        }

        async function getRefreshInterval() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            uniqueTickers.forEach((ticker) => {
                const isChecked = selectedTickers.includes(ticker);
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" ${isChecked ? "checked" : ""}>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                checkbox.addEventListener("change", () => {
                    const ticker = checkbox.querySelector("input").value;
                    if (checkbox.querySelector("input").checked) {
                        if (!selectedTickers.includes(ticker)) {
                            selectedTickers.push(ticker);
                        }
                    } else {
                        selectedTickers = selectedTickers.filter((t) => t !== ticker);
                    }
                    renderPortfolio();
                });

                filterCheckboxes.appendChild(checkbox);
            });
        }

        function filterPositions(positions, selectedTickers) {
            const filterInput = document.getElementById("filterInput");
            const filterText = filterInput.value.toLowerCase();
            return positions.filter((position) => {
                const tickerMatches = position.tickerSymbol.toLowerCase().includes(filterText);
                const isSelected = selectedTickers.includes(position.tickerSymbol);
                return tickerMatches && isSelected;
            });
        }

        document.addEventListener("DOMContentLoaded", async () => {
            // Toggle the settings visibility
            const settingsIcon = document.getElementById("settingsIcon");
            const settingsSection = document.getElementById("settings");

            settingsIcon.addEventListener("click", () => {
                if (settingsSection.style.display === "none" || !settingsSection.style.display) {
                    settingsSection.style.display = "block";
                } else {
                    settingsSection.style.display = "none";
                }
            });
            
            const refreshButtons = document.querySelectorAll(".refresh-interval-button");

            refreshButtons.forEach((button) => {
                button.addEventListener("click", async (event) => {
                    const selectedInterval = parseInt(event.target.getAttribute("data-interval"));
                    await saveRefreshInterval(selectedInterval);

                    refreshButtons.forEach((btn) => btn.classList.remove("btn-primary"));
                    event.target.classList.add("btn-primary");

                    startAutoRefresh();
                });
            });

            // Add event listener for the Save Settings button
            const saveKeysButton = document.getElementById("saveKeys");
            saveKeysButton.addEventListener("click", async () => {
                const alpacaKey = document.getElementById("alpacaApiKey").value;
                const alpacaSecret = document.getElementById("alpacaApiSecret").value;
                const finnhubKey = document.getElementById("apiKeyInput").value;

                try {
                    await saveKeys(alpacaKey, alpacaSecret, finnhubKey);
                    showFeedback("Settings saved successfully!", "success");
                } catch (error) {
                    console.error("Failed to save settings:", error);
                    showFeedback("Failed to save settings.", "danger");
                }
            });

            // Add sorting and dragging event listeners to table headers
            const tableHeaders = document.querySelectorAll("#portfolioTable thead th");
            let draggedHeader = null;
            let draggedOverHeader = null;

            tableHeaders.forEach((header) => {
                header.addEventListener("click", (event) => {
                    // Check if the click event was on the drag handle
                    if (event.target.closest('.drag-handle')) {
                        return; // Do nothing if the click was on the drag handle
                    }

                    const newSortColumn = header.getAttribute("data-sort-key");
                    const sortType = header.getAttribute("data-sort-type");

                    if (sortColumn === newSortColumn) {
                        // Toggle sort direction
                        sortDirection = sortDirection === "asc" ? "desc" : "asc";
                    } else {
                        // Set new sort column
                        sortColumn = newSortColumn;
                        sortDirection = "asc";
                    }

                    // Update sort arrow visibility
                    tableHeaders.forEach((h) => {
                        h.classList.remove("sorted-asc", "sorted-desc");
                    });
                    header.classList.add(sortDirection === "asc" ? "sorted-asc" : "sorted-desc");

                    // Sort the positions based on the selected column
                    allPositions.sort((a, b) => {
                        let aVal = a[sortColumn];
                        let bVal = b[sortColumn];

                        // Convert to appropriate type for comparison
                        if (sortType === "number") {
                            aVal = parseFloat(aVal);
                            bVal = parseFloat(bVal);
                        }

                        // Perform the comparison
                        if (aVal < bVal) {
                            return sortDirection === "asc" ? -1 : 1;
                        }
                        if (aVal > bVal) {
                            return sortDirection === "asc" ? 1 : -1;
                        }
                        return 0;
                    });

                    // Re-render the portfolio
                    renderPortfolio();
                });

                header.addEventListener("dragstart", (event) => {
                    draggedHeader = header;
                });

                header.addEventListener("dragover", (event) => {
                    event.preventDefault(); // Necessary to allow a drop
                    draggedOverHeader = header;
                });

                header.addEventListener("drop", (event) => {
                    event.preventDefault();
                    if (draggedHeader && draggedOverHeader && draggedHeader !== draggedOverHeader) {
                        reorderColumns(draggedHeader, draggedOverHeader);
                    }
                    draggedHeader = null;
                    draggedOverHeader = null;
                });
            });

            // Add event listener for the filter input
            const filterInput = document.getElementById("filterInput");
            filterInput.addEventListener("input", renderPortfolio);

            await loadSavedRefreshInterval();
            await loadPortfolio();
            await startAutoRefresh();
        });

        function reorderColumns(draggedHeader, targetHeader) {
            const table = document.getElementById("portfolioTable");
            const headerRow = table.querySelector("thead tr");
            const bodyRows = table.querySelectorAll("tbody tr");
            const footerRow = table.querySelector("tfoot tr");
            const draggedIndex = Array.from(headerRow.children).indexOf(draggedHeader);
            const targetIndex = Array.from(headerRow.children).indexOf(targetHeader);

            // Reorder headers
            if (draggedIndex < targetIndex) {
                headerRow.insertBefore(draggedHeader, targetHeader.nextSibling);
                if (footerRow) {
                    footerRow.insertBefore(footerRow.children[draggedIndex], footerRow.children[targetIndex].nextSibling);
                }
            } else {
                headerRow.insertBefore(draggedHeader, targetHeader);
                if (footerRow) {
                    footerRow.insertBefore(footerRow.children[draggedIndex], footerRow.children[targetIndex]);
                }
            }

            // Reorder cells in each body row
            bodyRows.forEach((row) => {
                const cells = Array.from(row.children);
                const draggedCell = cells[draggedIndex];
                const targetCell = cells[targetIndex];
                if (draggedIndex < targetIndex) {
                    row.insertBefore(draggedCell, targetCell.nextSibling);
                } else {
                    row.insertBefore(draggedCell, targetCell);
                }
            });
        }

        async function saveKeys(alpacaKey, alpacaSecret, finnhubKey) {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);

            appendDebugLog("Saving API keys...");

            if (alpacaKey) {
                store.put({ key: "APCA_API_KEY_ID", value: alpacaKey });
                appendDebugLog(`Alpaca Key saved: ${alpacaKey}`);
            }

            if (alpacaSecret) {
                store.put({ key: "APCA_API_SECRET_KEY", value: alpacaSecret });
                appendDebugLog("Alpaca Secret saved.");
            }

            if (finnhubKey) {
                store.put({ key: "finnhubApiKey", value: finnhubKey });
                appendDebugLog("Finnhub Key saved.");
            }

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    appendDebugLog("Settings saved successfully.");
                    resolve();
                };

                transaction.onerror = (event) => {
                    appendDebugLog(`Failed to save settings: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        function showFeedback(message, type) {
            const feedbackDiv = document.getElementById("settingsFeedback");
            feedbackDiv.textContent = message;
            feedbackDiv.className = `mt-2 text-${type}`; // Use Bootstrap text color classes
            feedbackDiv.style.display = "block";

            // Hide the feedback message after 3 seconds
            setTimeout(() => {
                feedbackDiv.style.display = "none";
            }, 3000);
        }

        async function saveRefreshInterval(interval) {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);

            store.put({ key: "refreshInterval", value: interval });

            return new Promise((resolve, reject) => {
                transaction.oncomplete = () => {
                    console.log("Refresh interval saved successfully!");
                    resolve();
                };
                transaction.onerror = (event) => {
                    console.error("Failed to save refresh interval.", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        async function loadSavedRefreshInterval() {
            const interval = await getRefreshInterval();
            const refreshButtons = document.querySelectorAll(".refresh-interval-button");

            refreshButtons.forEach((button) => {
                if (parseInt(button.getAttribute("data-interval")) === interval) {
                    button.classList.add("btn-primary");
                } else {
                    button.classList.remove("btn-primary");
                }
            });
        }

        function appendDebugLog(message) {
            const debugDiv = document.getElementById("debugLogs");
            const log = document.createElement("div");
            log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            debugDiv.appendChild(log);
        }
    </script>
    <div id="debugLogs" style="margin-top: 20px; color: #ff6f61; font-family: monospace;"></div>
</body>
</html>