<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
            position: relative;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            margin-top: 20px;
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 5px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 60px;
            height: 40px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #cccccc;
        }
        .th-name {
            margin-left: 25px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
        /* Debug Logs Styling */
        #debugLogs {
            background-color: #1e1e1e;
            padding: 10px;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            color: #ff6f61;
            font-family: monospace;
        }
        /* Customize Columns Styling */
        #sortableColumns .column-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            cursor: grab;
            padding: 5px 10px;
            background-color: #1e1e1e;
            border: 1px solid #444;
            color: #ffffff;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        #sortableColumns .column-item.dragging {
            opacity: 0.5;
        }
        /* Checkbox and Label Styling */
        #sortableColumns .form-check-input {
            accent-color: #00bcd4;
        }
        #sortableColumns .form-check-label {
            margin-left: 5px;
        }
        /* Active Refresh Interval Button Styling */
        .refresh-interval-button.active {
            background-color: #00bcd4;
            color: #fff;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./index.html">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Filter Section -->
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>

        <!-- Portfolio Table -->
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr id="portfolioHeaders">
                        <!-- Dynamic Headers will be inserted here -->
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row" id="totalsRow">
                        <!-- Totals will be inserted here -->
                    </tr>
                </tfoot>
            </table>
        </div>

        <!-- Auto-Refresh Interval Section -->
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>

        <!-- Settings Toggle -->
        <div class="settings-toggle text-end mt-4">
            <span id="settingsIcon"><i class="fas fa-cog"></i> Settings</span>
        </div>

        <!-- Settings Section -->
        <div class="settings d-none" id="settings">
            <h3>Settings</h3>
            <!-- Column Customization -->
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" class="list-group">
                    <!-- List items will be populated dynamically by JavaScript -->
                </ul>
                <button id="resetSettings" class="btn btn-secondary mt-3">Reset to Default</button>
            </div>

            <!-- API Keys Section -->
            <div class="mb-3">
                <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
                <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            </div>
            <div class="mb-3">
                <label for="alpacaApiSecret" class="form-label">Alpaca API Secret:</label>
                <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            </div>
            <div class="mb-3">
                <label for="finnhubApiKey" class="form-label">Finnhub API Key:</label>
                <input type="text" id="finnhubApiKey" class="form-control" placeholder="Enter your Finnhub API Key">
            </div>
            <button id="saveKeys" class="btn btn-primary">Save Settings</button>
        </div>

        <!-- Debug Logs Section -->
        <div id="debugLogs"></div>
    </div>

    <!-- Bootstrap JS and Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Font Awesome JS for Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/js/all.min.js"></script>
    <!-- Shared Database Script -->
    <script src="db.js"></script>
    <!-- Main JavaScript -->
    <script>
        // Database Configuration
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        // State Variables
        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let visibleColumns = [
            "tickerSymbol",
            "avgPrice",
            "numShares",
            "lastPrice",
            "costBasis",
            "totalValue",
            "profit",
            "profitPct",
            "changeToday",
            "changePctToday",
            "gapPct",
            "lastTime"
        ];

        // Define the available columns
        const availableColumns = [
            { key: "tickerSymbol", name: "Ticker" },
            { key: "avgPrice", name: "Average Price" },
            { key: "numShares", name: "Shares" },
            { key: "lastPrice", name: "Current Price" },
            { key: "costBasis", name: "Cost Basis" },
            { key: "totalValue", name: "Total Value" },
            { key: "profit", name: "Profit" },
            { key: "profitPct", name: "Profit %" },
            { key: "changeToday", name: "Change Today" },
            { key: "changePctToday", name: "Change % Today" },
            { key: "gapPct", name: "Gap %" },
            { key: "lastTime", name: "Time Since Last Trade" }
        ];

        /**
         * Appends a message to the debug logs.
         * @param {string} message - The message to append.
         */
        function appendDebugLog(message) {
            const debugLogs = document.getElementById("debugLogs");
            if (debugLogs) {
                const logEntry = document.createElement("div");
                logEntry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                debugLogs.appendChild(logEntry);
            } else {
                console.log(message); // Fallback to console if debugLogs element doesn't exist
            }
        }

        /**
         * Populates the sortable columns list in the settings section.
         */
        function populateSortableColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            sortableColumns.innerHTML = ""; // Clear existing list items

            // First, add columns in the order of visibleColumns
            visibleColumns.forEach(columnKey => {
                const column = availableColumns.find(col => col.key === columnKey);
                if (column) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Then, add the remaining columns not in visibleColumns
            availableColumns.forEach(column => {
                if (!visibleColumns.includes(column.key)) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Initialize Drag-and-Drop Functionality
            initializeDragAndDrop();

            console.log("Sortable columns populated successfully.");
            appendDebugLog("Sortable columns populated successfully.");
        }

        /**
         * Creates a list item for a column in the sortable columns list.
         * @param {Object} column - The column object containing key and name.
         * @returns {HTMLElement} The created list item element.
         */
        function createColumnListItem(column) {
            const li = document.createElement("li");
            li.className = "column-item list-group-item d-flex align-items-center";
            li.setAttribute("data-column", column.key);
            li.setAttribute("draggable", "true");

            li.innerHTML = `
                <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                <div class="form-check">
                    <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-${column.key}" value="${column.key}" ${visibleColumns.includes(column.key) ? "checked" : ""}>
                    <label class="form-check-label text-light" for="checkbox-${column.key}">${column.name}</label>
                </div>
            `;

            // Add Event Listener for Checkbox Change
            li.querySelector('.column-checkbox').addEventListener('change', () => {
                updateVisibleColumns();
                renderPortfolio();
            });

            return li;
        }

        /**
         * Initializes drag-and-drop functionality for sortable columns.
         */
        function initializeDragAndDrop() {
            const sortableColumns = document.getElementById("sortableColumns");
            let dragSrcEl = null;

            function handleDragStart(e) {
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', null); // For Firefox compatibility
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary to allow drop
                }
                e.dataTransfer.dropEffect = 'move'; // Show move cursor
                return false;
            }

            function handleDragEnter(e) {
                this.classList.add('over');
            }

            function handleDragLeave(e) {
                this.classList.remove('over');
            }

            function handleDrop(e) {
                if (e.stopPropagation) {
                    e.stopPropagation(); // Stops the browser from redirecting.
                }

                if (dragSrcEl !== this) {
                    // Reorder the DOM elements by inserting the dragged element before the drop target
                    sortableColumns.insertBefore(dragSrcEl, this);

                    // Update visibleColumns based on new order
                    updateVisibleColumns();
                    renderPortfolio();
                }
                return false;
            }

            function handleDragEnd(e) {
                this.classList.remove('dragging');
                const items = sortableColumns.querySelectorAll('.column-item');
                items.forEach(function (item) {
                    item.classList.remove('over');
                });
            }

            function addDnDHandlers(elem) {
                elem.addEventListener('dragstart', handleDragStart, false);
                elem.addEventListener('dragenter', handleDragEnter, false);
                elem.addEventListener('dragover', handleDragOver, false);
                elem.addEventListener('dragleave', handleDragLeave, false);
                elem.addEventListener('drop', handleDrop, false);
                elem.addEventListener('dragend', handleDragEnd, false);
            }

            const items = sortableColumns.querySelectorAll('.column-item');
            items.forEach(function(item) {
                addDnDHandlers(item);
            });
        }

        /**
         * Updates the visibleColumns array based on the current settings and saves it to IndexedDB.
         */
        async function updateVisibleColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            const columnItems = sortableColumns.querySelectorAll('.column-item');
            visibleColumns = Array.from(columnItems)
                .filter(item => item.querySelector('.column-checkbox').checked)
                .map(item => item.getAttribute('data-column'));

            // Ensure uniqueness to prevent duplicate columns
            visibleColumns = [...new Set(visibleColumns)];

            console.log("Updated visibleColumns:", visibleColumns);
            appendDebugLog("Updated visibleColumns.");

            // Save visibleColumns to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const request = store.put({ key: "visibleColumns", value: visibleColumns });

                request.onsuccess = () => {
                    appendDebugLog("Visible columns saved to settings.");
                };

                request.onerror = (event) => {
                    console.error("Error saving visible columns:", event.target.error);
                    appendDebugLog(`Error saving visible columns: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error saving visible columns:", error);
                appendDebugLog(`Error saving visible columns: ${error}`);
            }
        }

        /**
         * Fetches all visible positions from IndexedDB.
         * @returns {Promise<Array>} An array of visible positions.
         */
        async function fetchVisiblePositions() {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readonly");
                const store = transaction.objectStore(positionsStoreName);

                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = (event) => {
                        const all = event.target.result;
                        // Filter out positions where hide is true
                        const visible = all.filter(position => !position.hide);
                        resolve(visible);
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            } catch (error) {
                console.error("Error fetching visible positions:", error);
                appendDebugLog(`Error fetching visible positions: ${error}`);
                return [];
            }
        }

        /**
         * Fetches all unique tickers from IndexedDB.
         * @returns {Promise<Array>} An array of unique ticker symbols.
         */
        async function fetchAllTickers() {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readonly");
                const store = transaction.objectStore(positionsStoreName);
                const index = store.index("tickerSymbol");

                return new Promise((resolve, reject) => {
                    const request = index.openCursor(null, "nextunique");
                    const tickers = [];
                    request.onsuccess = (event) => {
                        const cursor = event.target.result;
                        if (cursor) {
                            tickers.push(cursor.key);
                            cursor.continue();
                        } else {
                            resolve(tickers);
                        }
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            } catch (error) {
                console.error("Error fetching all tickers:", error);
                appendDebugLog(`Error fetching all tickers: ${error}`);
                return [];
            }
        }

        /**
         * Generates filter checkboxes based on unique tickers.
         * @param {Array} uniqueTickers - An array of unique ticker symbols.
         */
        async function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            try {
                const db = await openDatabase();
                const store = db.transaction(positionsStoreName, "readonly").objectStore(positionsStoreName);

                for (const ticker of uniqueTickers) {
                    const checkbox = document.createElement("div");
                    checkbox.className = "form-check form-check-inline filter-checkbox";
                    checkbox.innerHTML = `
                        <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" checked>
                        <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                    `;

                    // Determine the initial checked state based on positions' hide attribute
                    const request = store.index("tickerSymbol").getAll(ticker);
                    request.onsuccess = (event) => {
                        const positions = event.target.result;
                        const isHidden = positions.every(pos => pos.hide); // Use 'every' for correct logic
                        if (isHidden) {
                            checkbox.querySelector('input').checked = false;
                        } else {
                            checkbox.querySelector('input').checked = true;
                        }
                    };
                    request.onerror = (event) => {
                        console.error(`Error fetching positions for ${ticker}:`, event.target.error);
                    };

                    // Add Event Listener for Checkbox Change
                    checkbox.querySelector('input').addEventListener("change", async () => {
                        const ticker = checkbox.querySelector("input").value;
                        const isChecked = checkbox.querySelector("input").checked;
                        const hide = !isChecked;

                        // Update the 'hide' attribute for all positions with this tickerSymbol
                        try {
                            await setHideForTickerSymbol(ticker, hide);
                            console.log(`Set hide=${hide} for tickerSymbol=${ticker}`);
                            appendDebugLog(`Set hide=${hide} for tickerSymbol=${ticker}`);

                            // Reload portfolio after updating hide status
                            await loadPortfolio();
                        } catch (error) {
                            console.error(`Error setting hide for tickerSymbol=${ticker}:`, error);
                            appendDebugLog(`Error setting hide for tickerSymbol=${ticker}: ${error}`);
                        }
                    });

                    filterCheckboxes.appendChild(checkbox);
                }
            } catch (error) {
                console.error("Error generating filter checkboxes:", error);
                appendDebugLog(`Error generating filter checkboxes: ${error}`);
            }
        }

        /**
         * Sets the 'hide' attribute for all positions with a specific ticker symbol.
         * @param {string} tickerSymbol - The ticker symbol.
         * @param {boolean} hide - Whether to hide the positions.
         */
        async function setHideForTickerSymbol(tickerSymbol, hide) {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readwrite");
                const store = transaction.objectStore(positionsStoreName);
                const index = store.index("tickerSymbol");

                const request = index.getAll(tickerSymbol);
                return new Promise((resolve, reject) => {
                    request.onsuccess = async (event) => {
                        const positions = event.target.result;
                        for (const position of positions) {
                            position.hide = hide;
                            const updateRequest = store.put(position);
                            await new Promise((res, rej) => {
                                updateRequest.onsuccess = () => res();
                                updateRequest.onerror = (e) => rej(e.target.error);
                            });
                        }
                        resolve();
                    };
                    request.onerror = (event) => reject(event.target.error);
                });
            } catch (error) {
                console.error(`Error setting hide for tickerSymbol=${tickerSymbol}:`, error);
                appendDebugLog(`Error setting hide for tickerSymbol=${tickerSymbol}: ${error}`);
                throw error;
            }
        }

        /**
         * Fetches current prices from Alpaca or Finnhub.
         * @param {Array} tickers - An array of ticker symbols.
         * @returns {Promise<Object>} An object mapping ticker symbols to their price data.
         */
        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                const alpacaKey = await new Promise((resolve, reject) => {
                    const request = store.get("APCA_API_KEY_ID");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                const alpacaSecret = await new Promise((resolve, reject) => {
                    const request = store.get("APCA_API_SECRET_KEY");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                if (alpacaKey && alpacaSecret) {
                    return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
                }

                console.warn("Alpaca credentials not available, falling back to Finnhub.");
                appendDebugLog("Alpaca credentials not available, falling back to Finnhub.");
                const finnhubKey = await new Promise((resolve, reject) => {
                    const request = store.get("finnhubApiKey");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                if (!finnhubKey) {
                    console.error("Finnhub API Key is not set. Please configure it in the settings.");
                    appendDebugLog("Finnhub API Key is not set. Please configure it in the settings.");
                    return {};
                }

                return await fetchPricesFromFinnhub(tickers, finnhubKey);
            } catch (error) {
                console.error("Error fetching current prices:", error);
                appendDebugLog(`Error fetching current prices: ${error}`);
                return {};
            }
        }

        /**
         * Fetches prices from Alpaca API.
         * @param {Array} tickers - An array of ticker symbols.
         * @param {string} apiKey - Alpaca API Key.
         * @param {string} apiSecret - Alpaca API Secret.
         * @returns {Promise<Object>} An object mapping ticker symbols to their price data.
         */
        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                for (const [symbol, snapshot] of Object.entries(data)) {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t ? new Date(snapshot.latestTrade.t).toLocaleString() : "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };
                }

                console.log("Fetched prices from Alpaca:", prices);
                appendDebugLog("Fetched prices from Alpaca.");
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                appendDebugLog(`Error fetching snapshots from Alpaca: ${error}`);
                return {};
            }
        }

        /**
         * Fetches prices from Finnhub API.
         * @param {Array} tickers - An array of ticker symbols.
         * @param {string} apiKey - Finnhub API Key.
         * @returns {Promise<Object>} An object mapping ticker symbols to their price data.
         */
        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            appendDebugLog(`Failed to fetch quote data for ${ticker} from Finnhub: ${quoteResponse.statusText}`);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                            appendDebugLog(`Failed to fetch previous close data for ${ticker} from Finnhub: ${prevCloseResponse.statusText}`);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                appendDebugLog("Fetched prices from Finnhub.");
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                appendDebugLog(`Error fetching prices from Finnhub: ${error}`);
                return {};
            }
        }

        /**
         * Renders the portfolio table based on visibleColumns and allPositions.
         */
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', async () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    sortPositions();
                    renderPortfolio();

                    // Save sort settings to IndexedDB
                    try {
                        const db = await openDatabase();
                        const transaction = db.transaction(settingsStoreName, "readwrite");
                        const store = transaction.objectStore(settingsStoreName);
                        const sortColumnRequest = store.put({ key: "sortColumn", value: sortColumn });
                        const sortDirectionRequest = store.put({ key: "sortDirection", value: sortDirection });

                        sortColumnRequest.onsuccess = () => {
                            appendDebugLog("Sort column saved.");
                        };
                        sortColumnRequest.onerror = (event) => {
                            console.error("Error saving sort column:", event.target.error);
                            appendDebugLog(`Error saving sort column: ${event.target.error}`);
                        };

                        sortDirectionRequest.onsuccess = () => {
                            appendDebugLog("Sort direction saved.");
                        };
                        sortDirectionRequest.onerror = (event) => {
                            console.error("Error saving sort direction:", event.target.error);
                            appendDebugLog(`Error saving sort direction: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error("Error saving sort settings:", error);
                        appendDebugLog(`Error saving sort settings: ${error}`);
                    }
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``; // We'll handle it dynamically
                return;
            }

            // Fetch batched prices for all symbols
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        /**
         * Determines the sort type based on the column key.
         * @param {string} columnKey - The key of the column.
         * @returns {string} The sort type ('string' or 'number').
         */
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        /**
         * Returns the display name for a given column key.
         * @param {string} columnKey - The key of the column.
         * @returns {string} The display name of the column.
         */
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        /**
         * Calculates the time since the last trade.
         * @param {string} lastTradeTime - The timestamp of the last trade.
         * @returns {string} A human-readable string representing the time since the last trade.
         */
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        /**
         * Sorts the allPositions array based on sortColumn and sortDirection.
         */
        function sortPositions() {
            if (!sortColumn) return; // No sorting applied

            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                // Handle undefined or null values
                valA = valA !== undefined && valA !== null ? valA : "";
                valB = valB !== undefined && valB !== null ? valB : "";

                if (typeof valA === "string") {
                    valA = valA.toLowerCase();
                }
                if (typeof valB === "string") {
                    valB = valB.toLowerCase();
                }

                if (valA < valB) {
                    return sortDirection === 'asc' ? -1 : 1;
                }
                if (valA > valB) {
                    return sortDirection === 'asc' ? 1 : -1;
                }
                return 0;
            });
        }

        /**
         * Renders the sortable columns and initializes sort settings.
         */
        async function initializeVisibleColumnsAndSortSettings() {
            try {
                const db = await openDatabase();
                const store = db.transaction(settingsStoreName, "readonly").objectStore(settingsStoreName);
                const savedColumns = await new Promise((resolve, reject) => {
                    const request = store.get("visibleColumns");
                    request.onsuccess = (event) => resolve(event.target.result?.value || []);
                    request.onerror = (event) => reject(event.target.error);
                });

                if (savedColumns.length > 0) {
                    visibleColumns = savedColumns;
                    // Ensure uniqueness
                    visibleColumns = [...new Set(visibleColumns)];

                    console.log("Loaded visibleColumns from settings:", visibleColumns);
                    appendDebugLog("Loaded visibleColumns from settings.");
                }

                // Load sort settings
                const savedSortColumn = await new Promise((resolve, reject) => {
                    const request = store.get("sortColumn");
                    request.onsuccess = (event) => resolve(event.target.result?.value || null);
                    request.onerror = (event) => reject(event.target.error);
                });
                const savedSortDirection = await new Promise((resolve, reject) => {
                    const request = store.get("sortDirection");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 'asc');
                    request.onerror = (event) => reject(event.target.error);
                });

                if (savedSortColumn) {
                    sortColumn = savedSortColumn;
                }
                if (savedSortDirection) {
                    sortDirection = savedSortDirection;
                }

                console.log("Loaded sort settings:", sortColumn, sortDirection);
                appendDebugLog("Loaded sort settings.");
            } catch (error) {
                console.error("Error initializing columns and sort settings:", error);
                appendDebugLog(`Error initializing columns and sort settings: ${error}`);
            }
        }

        /**
         * Populates and initializes everything on DOMContentLoaded.
         */
        document.addEventListener("DOMContentLoaded", async () => {
            await initializeVisibleColumnsAndSortSettings(); // Load saved column order and sort settings first
            populateSortableColumns();                      // Then populate the "Customize Columns" list based on saved order
            await loadPortfolio();
            await initializeRefreshIntervalButtons();
            await startAutoRefresh();
        });

        /**
         * Reset Settings Button Functionality
         */
        document.getElementById("resetSettings").addEventListener("click", async () => {
            // Reset visibleColumns to default
            visibleColumns = availableColumns.map(col => col.key);

            // Save to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const request = store.put({ key: "visibleColumns", value: visibleColumns });

                request.onsuccess = () => {
                    appendDebugLog("Visible columns reset to default in settings.");
                };

                request.onerror = (event) => {
                    console.error("Error resetting visible columns:", event.target.error);
                    appendDebugLog(`Error resetting visible columns: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error resetting visible columns:", error);
                appendDebugLog(`Error resetting visible columns: ${error}`);
            }

            // Reset sort settings
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const sortColumnRequest = store.put({ key: "sortColumn", value: null });
                const sortDirectionRequest = store.put({ key: "sortDirection", value: 'asc' });

                sortColumnRequest.onsuccess = () => {
                    appendDebugLog("Sort column reset to default in settings.");
                };
                sortColumnRequest.onerror = (event) => {
                    console.error("Error resetting sort column:", event.target.error);
                    appendDebugLog(`Error resetting sort column: ${event.target.error}`);
                };

                sortDirectionRequest.onsuccess = () => {
                    appendDebugLog("Sort direction reset to default in settings.");
                };
                sortDirectionRequest.onerror = (event) => {
                    console.error("Error resetting sort direction:", event.target.error);
                    appendDebugLog(`Error resetting sort direction: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error resetting sort settings:", error);
                appendDebugLog(`Error resetting sort settings: ${error}`);
            }

            // Reset hide attribute for all positions
            try {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readwrite");
                const store = transaction.objectStore(positionsStoreName);
                const request = store.getAll();

                request.onsuccess = async (event) => {
                    const positions = event.target.result;
                    for (const position of positions) {
                        position.hide = false;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    appendDebugLog("All positions set to visible.");
                    await loadPortfolio();
                };

                request.onerror = (event) => {
                    console.error("Error resetting positions' hide attributes:", event.target.error);
                    appendDebugLog(`Error resetting positions' hide attributes: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error resetting positions' hide attributes:", error);
                appendDebugLog(`Error resetting positions' hide attributes: ${error}`);
            }

            // Update UI
            populateSortableColumns();
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);

            // Provide user feedback
            const feedback = document.getElementById("settingsFeedback");
            feedback.textContent = "Settings reset to default.";
            feedback.style.display = "block";
            setTimeout(() => {
                feedback.style.display = "none";
            }, 3000);
        });

        /**
         * Saves API keys and refresh interval settings.
         */
        document.getElementById("saveKeys").addEventListener("click", async () => {
            const alpacaApiKey = document.getElementById("alpacaApiKey").value.trim();
            const alpacaApiSecret = document.getElementById("alpacaApiSecret").value.trim();
            const finnhubApiKey = document.getElementById("finnhubApiKey").value.trim();

            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                if (alpacaApiKey) {
                    const request = store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
                    request.onsuccess = () => {
                        appendDebugLog("Alpaca API Key saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Alpaca API Key:", event.target.error);
                        appendDebugLog(`Error saving Alpaca API Key: ${event.target.error}`);
                    };
                }

                if (alpacaApiSecret) {
                    const request = store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
                    request.onsuccess = () => {
                        appendDebugLog("Alpaca API Secret saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Alpaca API Secret:", event.target.error);
                        appendDebugLog(`Error saving Alpaca API Secret: ${event.target.error}`);
                    };
                }

                if (finnhubApiKey) {
                    const request = store.put({ key: "finnhubApiKey", value: finnhubApiKey });
                    request.onsuccess = () => {
                        appendDebugLog("Finnhub API Key saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Finnhub API Key:", event.target.error);
                        appendDebugLog(`Error saving Finnhub API Key: ${event.target.error}`);
                    };
                }

                // Provide user feedback
                const feedback = document.getElementById("settingsFeedback");
                feedback.textContent = "Settings saved successfully!";
                feedback.style.display = "block";
                setTimeout(() => {
                    feedback.style.display = "none";
                }, 3000);
            } catch (error) {
                console.error("Error saving API keys:", error);
                appendDebugLog(`Error saving API keys: ${error}`);
                alert("Failed to save settings. Please try again.");
            }
        });

        /**
         * Handles input filtering with debounce to optimize performance.
         */
        let debounceTimeout;
        document.getElementById("filterInput").addEventListener("input", () => {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                renderPortfolio();
            }, 300); // Adjust the debounce delay as needed
        });

        /**
         * Initializes auto-refresh interval buttons.
         */
        async function initializeRefreshIntervalButtons() {
            const buttons = document.querySelectorAll('.refresh-interval-button');
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const currentInterval = await new Promise((resolve, reject) => {
                    const request = store.get("refreshInterval");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                    request.onerror = (event) => reject(event.target.error);
                });

                buttons.forEach(button => {
                    if (parseInt(button.getAttribute('data-interval')) === currentInterval) {
                        button.classList.add('active');
                    }

                    button.addEventListener('click', async () => {
                        try {
                            const interval = parseInt(button.getAttribute('data-interval'));

                            // Save refreshInterval to IndexedDB
                            const putRequest = store.put({ key: "refreshInterval", value: interval });
                            putRequest.onsuccess = () => {
                                appendDebugLog(`Auto-refresh interval set to ${interval} seconds.`);
                            };
                            putRequest.onerror = (event) => {
                                console.error("Error setting refresh interval:", event.target.error);
                                appendDebugLog(`Error setting refresh interval: ${event.target.error}`);
                            };

                            // Update button styles
                            buttons.forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');

                            // Restart auto-refresh with the new interval
                            await startAutoRefresh();

                            // Provide user feedback
                            const feedback = document.getElementById("settingsFeedback");
                            feedback.textContent = interval === 0 ? "Auto-refresh stopped." : `Auto-refresh interval set to ${interval} seconds.`;
                            feedback.style.display = "block";
                            setTimeout(() => {
                                feedback.style.display = "none";
                            }, 3000);
                        } catch (error) {
                            console.error("Error setting refresh interval:", error);
                            appendDebugLog(`Error setting refresh interval: ${error}`);
                            alert("Failed to set refresh interval.");
                        }
                    });
                });

                console.log("Refresh interval buttons initialized.");
                appendDebugLog("Refresh interval buttons initialized.");
            } catch (error) {
                console.error("Error initializing refresh interval buttons:", error);
                appendDebugLog(`Error initializing refresh interval buttons: ${error}`);
            }
        }

        /**
         * Initializes the visible columns and sort settings from IndexedDB.
         */
        async function initializeVisibleColumnsAndSortSettings() {
            try {
                const db = await openDatabase();
                const store = db.transaction(settingsStoreName, "readonly").objectStore(settingsStoreName);
                const savedColumns = await new Promise((resolve, reject) => {
                    const request = store.get("visibleColumns");
                    request.onsuccess = (event) => resolve(event.target.result?.value || []);
                    request.onerror = (event) => reject(event.target.error);
                });

                if (savedColumns.length > 0) {
                    visibleColumns = savedColumns;
                    // Ensure uniqueness
                    visibleColumns = [...new Set(visibleColumns)];

                    console.log("Loaded visibleColumns from settings:", visibleColumns);
                    appendDebugLog("Loaded visibleColumns from settings.");
                }

                // Load sort settings
                const savedSortColumn = await new Promise((resolve, reject) => {
                    const request = store.get("sortColumn");
                    request.onsuccess = (event) => resolve(event.target.result?.value || null);
                    request.onerror = (event) => reject(event.target.error);
                });
                const savedSortDirection = await new Promise((resolve, reject) => {
                    const request = store.get("sortDirection");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 'asc');
                    request.onerror = (event) => reject(event.target.error);
                });

                if (savedSortColumn) {
                    sortColumn = savedSortColumn;
                }
                if (savedSortDirection) {
                    sortDirection = savedSortDirection;
                }

                console.log("Loaded sort settings:", sortColumn, sortDirection);
                appendDebugLog("Loaded sort settings.");
            } catch (error) {
                console.error("Error initializing columns and sort settings:", error);
                appendDebugLog(`Error initializing columns and sort settings: ${error}`);
            }
        }

        /**
         * Opens the portfolio page by loading positions and initializing UI components.
         */
        async function loadPortfolio() {
            try {
                allPositions = await fetchVisiblePositions();
                // Calculate and append additional fields to each position
                allPositions = allPositions.map(position => {
                    const currentPrice = position.lastPrice || 0;
                    const costBasis = position.avgPrice * position.numShares;
                    const totalValue = currentPrice * position.numShares;
                    const profit = totalValue - costBasis;
                    const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                    const changeToday = position.changeToday || 0;
                    const changePctToday = position.changePctToday || 0;
                    const gapPct = position.gapPct || 0;
                    const timeSinceLastTrade = position.lastTime || "N/A";

                    return {
                        ...position,
                        costBasis,
                        totalValue,
                        profit,
                        profitPct,
                        changeToday,
                        changePctToday,
                        gapPct,
                        timeSinceLastTrade
                    };
                });

                sortPositions(); // Sort after adding calculated fields
                renderPortfolio();
            } catch (error) {
                console.error("Error loading portfolio:", error);
                appendDebugLog(`Error loading portfolio: ${error}`);
            }
        }

        /**
         * Renders the portfolio table based on visibleColumns and allPositions.
         */
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', async () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    sortPositions();
                    renderPortfolio();

                    // Save sort settings to IndexedDB
                    try {
                        const db = await openDatabase();
                        const transaction = db.transaction(settingsStoreName, "readwrite");
                        const store = transaction.objectStore(settingsStoreName);
                        const sortColumnRequest = store.put({ key: "sortColumn", value: sortColumn });
                        const sortDirectionRequest = store.put({ key: "sortDirection", value: sortDirection });

                        sortColumnRequest.onsuccess = () => {
                            appendDebugLog("Sort column saved.");
                        };
                        sortColumnRequest.onerror = (event) => {
                            console.error("Error saving sort column:", event.target.error);
                            appendDebugLog(`Error saving sort column: ${event.target.error}`);
                        };

                        sortDirectionRequest.onsuccess = () => {
                            appendDebugLog("Sort direction saved.");
                        };
                        sortDirectionRequest.onerror = (event) => {
                            console.error("Error saving sort direction:", event.target.error);
                            appendDebugLog(`Error saving sort direction: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error("Error saving sort settings:", error);
                        appendDebugLog(`Error saving sort settings: ${error}`);
                    }
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``; // We'll handle it dynamically
                return;
            }

            // Fetch batched prices for all symbols
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        /**
         * Determines the sort type based on the column key.
         * @param {string} columnKey - The key of the column.
         * @returns {string} The sort type ('string' or 'number').
         */
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        /**
         * Returns the display name for a given column key.
         * @param {string} columnKey - The key of the column.
         * @returns {string} The display name of the column.
         */
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        /**
         * Calculates the time since the last trade.
         * @param {string} lastTradeTime - The timestamp of the last trade.
         * @returns {string} A human-readable string representing the time since the last trade.
         */
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        /**
         * Sets the auto-refresh interval based on settings.
         */
        async function startAutoRefresh() {
            try {
                const interval = await getRefreshInterval();
                if (refreshIntervalId) {
                    clearInterval(refreshIntervalId);
                }

                if (interval > 0) {
                    refreshIntervalId = setInterval(async () => {
                        console.log("Auto-refreshing prices...");
                        appendDebugLog("Auto-refreshing prices...");
                        await loadPortfolio();
                    }, interval * 1000);
                    console.log(`Auto-refresh set to every ${interval} seconds.`);
                    appendDebugLog(`Auto-refresh set to every ${interval} seconds.`);
                } else {
                    console.log("Auto-refresh stopped.");
                    appendDebugLog("Auto-refresh stopped.");
                }
            } catch (error) {
                console.error("Error starting auto-refresh:", error);
                appendDebugLog(`Error starting auto-refresh: ${error}`);
            }
        }

        /**
         * Retrieves the current refresh interval from IndexedDB.
         * @returns {Promise<number>} The refresh interval in seconds.
         */
        async function getRefreshInterval() {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                const request = store.get("refreshInterval");
                return new Promise((resolve, reject) => {
                    request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                    request.onerror = (event) => reject(event.target.error);
                });
            } catch (error) {
                console.error("Error getting refresh interval:", error);
                appendDebugLog(`Error getting refresh interval: ${error}`);
                return 0;
            }
        }

        /**
         * Sorts the allPositions array based on sortColumn and sortDirection.
         */
        function sortPositions() {
            if (!sortColumn) return; // No sorting applied

            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                // Handle undefined or null values
                valA = valA !== undefined && valA !== null ? valA : "";
                valB = valB !== undefined && valB !== null ? valB : "";

                if (typeof valA === "string") {
                    valA = valA.toLowerCase();
                }
                if (typeof valB === "string") {
                    valB = valB.toLowerCase();
                }

                if (valA < valB) {
                    return sortDirection === 'asc' ? -1 : 1;
                }
                if (valA > valB) {
                    return sortDirection === 'asc' ? 1 : -1;
                }
                return 0;
            });
        }

        /**
         * Renders the portfolio table based on visibleColumns and allPositions.
         */
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', async () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    sortPositions();
                    renderPortfolio();

                    // Save sort settings to IndexedDB
                    try {
                        const db = await openDatabase();
                        const transaction = db.transaction(settingsStoreName, "readwrite");
                        const store = transaction.objectStore(settingsStoreName);
                        const sortColumnRequest = store.put({ key: "sortColumn", value: sortColumn });
                        const sortDirectionRequest = store.put({ key: "sortDirection", value: sortDirection });

                        sortColumnRequest.onsuccess = () => {
                            appendDebugLog("Sort column saved.");
                        };
                        sortColumnRequest.onerror = (event) => {
                            console.error("Error saving sort column:", event.target.error);
                            appendDebugLog(`Error saving sort column: ${event.target.error}`);
                        };

                        sortDirectionRequest.onsuccess = () => {
                            appendDebugLog("Sort direction saved.");
                        };
                        sortDirectionRequest.onerror = (event) => {
                            console.error("Error saving sort direction:", event.target.error);
                            appendDebugLog(`Error saving sort direction: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error("Error saving sort settings:", error);
                        appendDebugLog(`Error saving sort settings: ${error}`);
                    }
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``; // We'll handle it dynamically
                return;
            }

            // Fetch batched prices for all symbols
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        /**
         * Handles the Settings toggle button to show/hide the settings section.
         */
        document.getElementById("settingsIcon").addEventListener("click", () => {
            const settingsDiv = document.getElementById("settings");
            settingsDiv.classList.toggle("d-none");
        });

        /**
         * Saves API keys and refresh interval settings.
         */
        document.getElementById("saveKeys").addEventListener("click", async () => {
            const alpacaApiKey = document.getElementById("alpacaApiKey").value.trim();
            const alpacaApiSecret = document.getElementById("alpacaApiSecret").value.trim();
            const finnhubApiKey = document.getElementById("finnhubApiKey").value.trim();

            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                if (alpacaApiKey) {
                    const request = store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
                    request.onsuccess = () => {
                        appendDebugLog("Alpaca API Key saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Alpaca API Key:", event.target.error);
                        appendDebugLog(`Error saving Alpaca API Key: ${event.target.error}`);
                    };
                }

                if (alpacaApiSecret) {
                    const request = store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
                    request.onsuccess = () => {
                        appendDebugLog("Alpaca API Secret saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Alpaca API Secret:", event.target.error);
                        appendDebugLog(`Error saving Alpaca API Secret: ${event.target.error}`);
                    };
                }

                if (finnhubApiKey) {
                    const request = store.put({ key: "finnhubApiKey", value: finnhubApiKey });
                    request.onsuccess = () => {
                        appendDebugLog("Finnhub API Key saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Finnhub API Key:", event.target.error);
                        appendDebugLog(`Error saving Finnhub API Key: ${event.target.error}`);
                    };
                }

                // Provide user feedback
                const feedback = document.getElementById("settingsFeedback");
                feedback.textContent = "Settings saved successfully!";
                feedback.style.display = "block";
                setTimeout(() => {
                    feedback.style.display = "none";
                }, 3000);
            } catch (error) {
                console.error("Error saving API keys:", error);
                appendDebugLog(`Error saving API keys: ${error}`);
                alert("Failed to save settings. Please try again.");
            }
        });

        /**
         * Handles input filtering with debounce to optimize performance.
         */
        let debounceTimeout;
        document.getElementById("filterInput").addEventListener("input", () => {
            clearTimeout(debounceTimeout);
            debounceTimeout = setTimeout(() => {
                renderPortfolio();
            }, 300); // Adjust the debounce delay as needed
        });

        /**
         * Initializes auto-refresh interval buttons.
         */
        async function initializeRefreshIntervalButtons() {
            const buttons = document.querySelectorAll('.refresh-interval-button');
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const currentInterval = await new Promise((resolve, reject) => {
                    const request = store.get("refreshInterval");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                    request.onerror = (event) => reject(event.target.error);
                });

                buttons.forEach(button => {
                    if (parseInt(button.getAttribute('data-interval')) === currentInterval) {
                        button.classList.add('active');
                    }

                    button.addEventListener('click', async () => {
                        try {
                            const interval = parseInt(button.getAttribute('data-interval'));

                            // Save refreshInterval to IndexedDB
                            const putRequest = store.put({ key: "refreshInterval", value: interval });
                            putRequest.onsuccess = () => {
                                appendDebugLog(`Auto-refresh interval set to ${interval} seconds.`);
                            };
                            putRequest.onerror = (event) => {
                                console.error("Error setting refresh interval:", event.target.error);
                                appendDebugLog(`Error setting refresh interval: ${event.target.error}`);
                            };

                            // Update button styles
                            buttons.forEach(btn => btn.classList.remove('active'));
                            button.classList.add('active');

                            // Restart auto-refresh with the new interval
                            await startAutoRefresh();

                            // Provide user feedback
                            const feedback = document.getElementById("settingsFeedback");
                            feedback.textContent = interval === 0 ? "Auto-refresh stopped." : `Auto-refresh interval set to ${interval} seconds.`;
                            feedback.style.display = "block";
                            setTimeout(() => {
                                feedback.style.display = "none";
                            }, 3000);
                        } catch (error) {
                            console.error("Error setting refresh interval:", error);
                            appendDebugLog(`Error setting refresh interval: ${error}`);
                            alert("Failed to set refresh interval.");
                        }
                    });
                });

                console.log("Refresh interval buttons initialized.");
                appendDebugLog("Refresh interval buttons initialized.");
            } catch (error) {
                console.error("Error initializing refresh interval buttons:", error);
                appendDebugLog(`Error initializing refresh interval buttons: ${error}`);
            }
        }

        /**
         * Initializes the visible columns and sort settings from IndexedDB.
         */
        async function initializeVisibleColumnsAndSortSettings() {
            try {
                const db = await openDatabase();
                const store = db.transaction(settingsStoreName, "readonly").objectStore(settingsStoreName);
                const savedColumns = await new Promise((resolve, reject) => {
                    const request = store.get("visibleColumns");
                    request.onsuccess = (event) => resolve(event.target.result?.value || []);
                    request.onerror = (event) => reject(event.target.error);
                });

                if (savedColumns.length > 0) {
                    visibleColumns = savedColumns;
                    // Ensure uniqueness
                    visibleColumns = [...new Set(visibleColumns)];

                    console.log("Loaded visibleColumns from settings:", visibleColumns);
                    appendDebugLog("Loaded visibleColumns from settings.");
                }

                // Load sort settings
                const savedSortColumn = await new Promise((resolve, reject) => {
                    const request = store.get("sortColumn");
                    request.onsuccess = (event) => resolve(event.target.result?.value || null);
                    request.onerror = (event) => reject(event.target.error);
                });
                const savedSortDirection = await new Promise((resolve, reject) => {
                    const request = store.get("sortDirection");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 'asc');
                    request.onerror = (event) => reject(event.target.error);
                });

                if (savedSortColumn) {
                    sortColumn = savedSortColumn;
                }
                if (savedSortDirection) {
                    sortDirection = savedSortDirection;
                }

                console.log("Loaded sort settings:", sortColumn, sortDirection);
                appendDebugLog("Loaded sort settings.");
            } catch (error) {
                console.error("Error initializing columns and sort settings:", error);
                appendDebugLog(`Error initializing columns and sort settings: ${error}`);
            }
        }

        /**
         * Opens the portfolio page by loading positions and initializing UI components.
         */
        async function loadPortfolio() {
            try {
                allPositions = await fetchVisiblePositions();
                // Calculate and append additional fields to each position
                allPositions = allPositions.map(position => {
                    const currentPrice = position.lastPrice || 0;
                    const costBasis = position.avgPrice * position.numShares;
                    const totalValue = currentPrice * position.numShares;
                    const profit = totalValue - costBasis;
                    const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                    const changeToday = position.changeToday || 0;
                    const changePctToday = position.changePctToday || 0;
                    const gapPct = position.gapPct || 0;
                    const timeSinceLastTrade = position.lastTime || "N/A";

                    return {
                        ...position,
                        costBasis,
                        totalValue,
                        profit,
                        profitPct,
                        changeToday,
                        changePctToday,
                        gapPct,
                        timeSinceLastTrade
                    };
                });

                sortPositions(); // Sort after adding calculated fields
                renderPortfolio();
            } catch (error) {
                console.error("Error loading portfolio:", error);
                appendDebugLog(`Error loading portfolio: ${error}`);
            }
        }

        /**
         * Fetches and renders the portfolio table.
         */
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', async () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    sortPositions();
                    renderPortfolio();

                    // Save sort settings to IndexedDB
                    try {
                        const db = await openDatabase();
                        const transaction = db.transaction(settingsStoreName, "readwrite");
                        const store = transaction.objectStore(settingsStoreName);
                        const sortColumnRequest = store.put({ key: "sortColumn", value: sortColumn });
                        const sortDirectionRequest = store.put({ key: "sortDirection", value: sortDirection });

                        sortColumnRequest.onsuccess = () => {
                            appendDebugLog("Sort column saved.");
                        };
                        sortColumnRequest.onerror = (event) => {
                            console.error("Error saving sort column:", event.target.error);
                            appendDebugLog(`Error saving sort column: ${event.target.error}`);
                        };

                        sortDirectionRequest.onsuccess = () => {
                            appendDebugLog("Sort direction saved.");
                        };
                        sortDirectionRequest.onerror = (event) => {
                            console.error("Error saving sort direction:", event.target.error);
                            appendDebugLog(`Error saving sort direction: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error("Error saving sort settings:", error);
                        appendDebugLog(`Error saving sort settings: ${error}`);
                    }
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``; // We'll handle it dynamically
                return;
            }

            // Fetch batched prices for all symbols
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        /**
         * Gets the sort type based on the column key.
         * @param {string} columnKey - The key of the column.
         * @returns {string} The sort type ('string' or 'number').
         */
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        /**
         * Gets the display name for a column based on its key.
         * @param {string} columnKey - The key of the column.
         * @returns {string} The display name of the column.
         */
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        /**
         * Calculates the time since the last trade in a human-readable format.
         * @param {string} lastTradeTime - The timestamp of the last trade.
         * @returns {string} The formatted time since the last trade.
         */
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        /**
         * Fetches and renders the portfolio table.
         */
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', async () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    sortPositions();
                    renderPortfolio();

                    // Save sort settings to IndexedDB
                    try {
                        const db = await openDatabase();
                        const transaction = db.transaction(settingsStoreName, "readwrite");
                        const store = transaction.objectStore(settingsStoreName);
                        const sortColumnRequest = store.put({ key: "sortColumn", value: sortColumn });
                        const sortDirectionRequest = store.put({ key: "sortDirection", value: sortDirection });

                        sortColumnRequest.onsuccess = () => {
                            appendDebugLog("Sort column saved.");
                        };
                        sortColumnRequest.onerror = (event) => {
                            console.error("Error saving sort column:", event.target.error);
                            appendDebugLog(`Error saving sort column: ${event.target.error}`);
                        };

                        sortDirectionRequest.onsuccess = () => {
                            appendDebugLog("Sort direction saved.");
                        };
                        sortDirectionRequest.onerror = (event) => {
                            console.error("Error saving sort direction:", event.target.error);
                            appendDebugLog(`Error saving sort direction: ${event.target.error}`);
                        };
                    } catch (error) {
                        console.error("Error saving sort settings:", error);
                        appendDebugLog(`Error saving sort settings: ${error}`);
                    }
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``; // We'll handle it dynamically
                return;
            }

            // Fetch batched prices for all symbols
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            const priceData = await fetchCurrentPrices(uniqueTickers);
            console.log("Price Data:", priceData); // Debug log

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            allPositions.forEach((position) => {
                const priceInfo = priceData[position.tickerSymbol] || {};
                const currentPrice = priceInfo.price || position.lastPrice || 0;
                const lastTime = priceInfo.time || "N/A";
                const openPrice = priceInfo.open || position.openPrice || 0;
                const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                // Update calculated fields
                position.costBasis = position.avgPrice * position.numShares;
                position.totalValue = currentPrice * position.numShares;
                position.profit = position.totalValue - position.costBasis;
                position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                position.changeToday = currentPrice - prevClosePrice;
                position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += position.costBasis;
                totals.totalValue += position.totalValue;
                totals.profit += position.profit;
                totals.profitPct += position.profitPct;
                totals.changeToday += position.changeToday;
                totals.changePctToday += position.changePctToday;
                totals.gapPct += position.gapPct;

                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = currentPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        /**
         * Handles the Settings toggle button to show/hide the settings section.
         */
        document.getElementById("settingsIcon").addEventListener("click", () => {
            const settingsDiv = document.getElementById("settings");
            settingsDiv.classList.toggle("d-none");
        });

        /**
         * Saves API keys and refresh interval settings.
         */
        document.getElementById("saveKeys").addEventListener("click", async () => {
            const alpacaApiKey = document.getElementById("alpacaApiKey").value.trim();
            const alpacaApiSecret = document.getElementById("alpacaApiSecret").value.trim();
            const finnhubApiKey = document.getElementById("finnhubApiKey").value.trim();

            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                if (alpacaApiKey) {
                    const request = store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
                    request.onsuccess = () => {
                        appendDebugLog("Alpaca API Key saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Alpaca API Key:", event.target.error);
                        appendDebugLog(`Error saving Alpaca API Key: ${event.target.error}`);
                    };
                }

                if (alpacaApiSecret) {
                    const request = store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
                    request.onsuccess = () => {
                        appendDebugLog("Alpaca API Secret saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Alpaca API Secret:", event.target.error);
                        appendDebugLog(`Error saving Alpaca API Secret: ${event.target.error}`);
                    };
                }

                if (finnhubApiKey) {
                    const request = store.put({ key: "finnhubApiKey", value: finnhubApiKey });
                    request.onsuccess = () => {
                        appendDebugLog("Finnhub API Key saved.");
                    };
                    request.onerror = (event) => {
                        console.error("Error saving Finnhub API Key:", event.target.error);
                        appendDebugLog(`Error saving Finnhub API Key: ${event.target.error}`);
                    };
                }

                // Provide user feedback
                const feedback = document.getElementById("settingsFeedback");
                feedback.textContent = "Settings saved successfully!";
                feedback.style.display = "block";
                setTimeout(() => {
                    feedback.style.display = "none";
                }, 3000);
            } catch (error) {
                console.error("Error saving API keys:", error);
                appendDebugLog(`Error saving API keys: ${error}`);
                alert("Failed to save settings. Please try again.");
            }
        });

        /**
         * Generates filter checkboxes and initializes them.
         */
        async function initializeFilterCheckboxes() {
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);
        }

        /**
         * Initializes everything on DOMContentLoaded.
         */
        document.addEventListener("DOMContentLoaded", async () => {
            await initializeVisibleColumnsAndSortSettings(); // Load saved column order and sort settings first
            populateSortableColumns();                      // Then populate the "Customize Columns" list based on saved order
            await loadPortfolio();
            await initializeRefreshIntervalButtons();
            await initializeFilterCheckboxes();
            await startAutoRefresh();
        });

        /**
         * Resets all settings to their default values.
         */
        document.getElementById("resetSettings").addEventListener("click", async () => {
            // Reset visibleColumns to default
            visibleColumns = availableColumns.map(col => col.key);

            // Save to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const request = store.put({ key: "visibleColumns", value: visibleColumns });

                request.onsuccess = () => {
                    appendDebugLog("Visible columns reset to default in settings.");
                };

                request.onerror = (event) => {
                    console.error("Error resetting visible columns:", event.target.error);
                    appendDebugLog(`Error resetting visible columns: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error resetting visible columns:", error);
                appendDebugLog(`Error resetting visible columns: ${error}`);
            }

            // Reset sort settings
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const sortColumnRequest = store.put({ key: "sortColumn", value: null });
                const sortDirectionRequest = store.put({ key: "sortDirection", value: 'asc' });

                sortColumnRequest.onsuccess = () => {
                    appendDebugLog("Sort column reset to default in settings.");
                };
                sortColumnRequest.onerror = (event) => {
                    console.error("Error resetting sort column:", event.target.error);
                    appendDebugLog(`Error resetting sort column: ${event.target.error}`);
                };

                sortDirectionRequest.onsuccess = () => {
                    appendDebugLog("Sort direction reset to default in settings.");
                };
                sortDirectionRequest.onerror = (event) => {
                    console.error("Error resetting sort direction:", event.target.error);
                    appendDebugLog(`Error resetting sort direction: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error resetting sort settings:", error);
                appendDebugLog(`Error resetting sort settings: ${error}`);
            }

            // Reset hide attribute for all positions
            try {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readwrite");
                const store = transaction.objectStore(positionsStoreName);
                const request = store.getAll();

                request.onsuccess = async (event) => {
                    const positions = event.target.result;
                    for (const position of positions) {
                        position.hide = false;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    appendDebugLog("All positions set to visible.");
                    await loadPortfolio();
                };

                request.onerror = (event) => {
                    console.error("Error resetting positions' hide attributes:", event.target.error);
                    appendDebugLog(`Error resetting positions' hide attributes: ${event.target.error}`);
                };
            } catch (error) {
                console.error("Error resetting positions' hide attributes:", error);
                appendDebugLog(`Error resetting positions' hide attributes: ${error}`);
            }

            // Update UI
            populateSortableColumns();
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);

            // Provide user feedback
            const feedback = document.getElementById("settingsFeedback");
            feedback.textContent = "Settings reset to default.";
            feedback.style.display = "block";
            setTimeout(() => {
                feedback.style.display = "none";
            }, 3000);
        });

        /**
         * Starts the auto-refresh interval based on settings.
         */
        async function startAutoRefresh() {
            try {
                const interval = await getRefreshInterval();
                if (refreshIntervalId) {
                    clearInterval(refreshIntervalId);
                }

                if (interval > 0) {
                    refreshIntervalId = setInterval(async () => {
                        console.log("Auto-refreshing prices...");
                        appendDebugLog("Auto-refreshing prices...");
                        await loadPortfolio();
                    }, interval * 1000);
                    console.log(`Auto-refresh set to every ${interval} seconds.`);
                    appendDebugLog(`Auto-refresh set to every ${interval} seconds.`);
                } else {
                    console.log("Auto-refresh stopped.");
                    appendDebugLog("Auto-refresh stopped.");
                }
            } catch (error) {
                console.error("Error starting auto-refresh:", error);
                appendDebugLog(`Error starting auto-refresh: ${error}`);
            }
        }
    </script>
</body>
</html>