<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            display: none;
            margin-top: 20px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #666;
        }
        .th-name {
            margin-left: 20px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
        /* Debug Logs Styling */
        #debugLogs {
            background-color: #1e1e1e;
            padding: 10px;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            display: none; /* Initially hidden */
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Filter Section -->
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>

        <!-- Portfolio Table -->
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr id="portfolioHeaders">
                        <!-- Dynamic Headers will be inserted here -->
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row" id="totalsRow">
                        <!-- Totals will be inserted here -->
                    </tr>
                </tfoot>
            </table>
        </div>

        <!-- Auto-Refresh Interval Section -->
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>

        <!-- Settings Toggle -->
        <div class="settings-toggle text-end">
            <span id="settingsIcon">⚙️ Settings</span>
        </div>

        <!-- Settings Section -->
        <div class="settings" id="settings">
            <h3>Settings</h3>
            <!-- Column Customization -->
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" class="list-group">
                    <li class="column-item list-group-item d-flex align-items-center" data-column="tickerSymbol" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-tickerSymbol" value="tickerSymbol" checked>
                        <label class="form-check-label text-light" for="checkbox-tickerSymbol">Ticker</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="avgPrice" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-avgPrice" value="avgPrice" checked>
                        <label class="form-check-label text-light" for="checkbox-avgPrice">Average Price</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="numShares" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-numShares" value="numShares" checked>
                        <label class="form-check-label text-light" for="checkbox-numShares">Shares</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="lastPrice" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-lastPrice" value="lastPrice" checked>
                        <label class="form-check-label text-light" for="checkbox-lastPrice">Current Price</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="costBasis" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-costBasis" value="costBasis" checked>
                        <label class="form-check-label text-light" for="checkbox-costBasis">Cost Basis</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="totalValue" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-totalValue" value="totalValue" checked>
                        <label class="form-check-label text-light" for="checkbox-totalValue">Total Value</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="profit" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-profit" value="profit" checked>
                        <label class="form-check-label text-light" for="checkbox-profit">Profit</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="profitPct" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-profitPct" value="profitPct" checked>
                        <label class="form-check-label text-light" for="checkbox-profitPct">Profit %</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="changeToday" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-changeToday" value="changeToday" checked>
                        <label class="form-check-label text-light" for="checkbox-changeToday">Change Today</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="changePctToday" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-changePctToday" value="changePctToday" checked>
                        <label class="form-check-label text-light" for="checkbox-changePctToday">Change % Today</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="gapPct" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-gapPct" value="gapPct" checked>
                        <label class="form-check-label text-light" for="checkbox-gapPct">Gap %</label>
                    </li>
                    <li class="column-item list-group-item d-flex align-items-center" data-column="lastTime" draggable="true">
                        <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                        <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-lastTime" value="lastTime" checked>
                        <label class="form-check-label text-light" for="checkbox-lastTime">Time Since Last Trade</label>
                    </li>
                </ul>
            </div>

            <!-- API Keys Section -->
            <div class="mb-3">
                <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
                <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            </div>
            <div class="mb-3">
                <label for="alpacaApiSecret" class="form-label">Alpaca API Secret:</label>
                <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            </div>
            <div class="mb-3">
                <label for="finnhubApiKey" class="form-label">Finnhub API Key:</label>
                <input type="text" id="finnhubApiKey" class="form-control" placeholder="Enter your Finnhub API Key">
            </div>
            <button id="saveKeys" class="btn btn-primary">Save Settings</button>
        </div>

        <!-- Debug Logs Section (Optional) -->
        <div id="debugLogs"></div>

        <!-- Bootstrap JS and Dependencies -->
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Main JavaScript -->
        <script>
            // Database Configuration
            const dbName = "ProfitLadderDB";
            const positionsStoreName = "Positions";
            const settingsStoreName = "Settings";

            // State Variables
            let refreshIntervalId;
            let sortColumn = null;
            let sortDirection = 'asc';
            let allPositions = [];
            let selectedTickers = [];
            let visibleColumns = [
                "tickerSymbol",
                "avgPrice",
                "numShares",
                "lastPrice",
                "costBasis",
                "totalValue",
                "profit",
                "profitPct",
                "changeToday",
                "changePctToday",
                "gapPct",
                "lastTime"
            ];

            // Function to Open IndexedDB
            async function openDatabase() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(dbName, 2);
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;

                        if (!db.objectStoreNames.contains(positionsStoreName)) {
                            db.createObjectStore(positionsStoreName, { keyPath: "tickerSymbol" });
                            appendDebugLog("Created 'Positions' object store.");
                        }

                        if (!db.objectStoreNames.contains(settingsStoreName)) {
                            db.createObjectStore(settingsStoreName, { keyPath: "key" });
                            appendDebugLog("Created 'Settings' object store.");
                        }
                    };

                    request.onsuccess = (event) => {
                        const db = event.target.result;
                        resolve(db);
                    };

                    request.onerror = (event) => {
                        appendDebugLog(`Database open failed: ${event.target.error}`);
                        reject(event.target.error);
                    };
                });
            }

            // Function to Fetch Current Prices
            async function fetchCurrentPrices(tickers) {
                if (!tickers || tickers.length === 0) {
                    return {};
                }

                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                const alpacaKey = await new Promise((resolve, reject) => {
                    const request = store.get("APCA_API_KEY_ID");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                const alpacaSecret = await new Promise((resolve, reject) => {
                    const request = store.get("APCA_API_SECRET_KEY");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                if (alpacaKey && alpacaSecret) {
                    return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
                }

                console.warn("Alpaca credentials not available, falling back to Finnhub.");
                const finnhubKey = await new Promise((resolve, reject) => {
                    const request = store.get("finnhubApiKey");
                    request.onsuccess = (event) => resolve(event.target.result?.value || "");
                    request.onerror = (event) => reject(event.target.error);
                });

                if (!finnhubKey) {
                    console.error("Finnhub API Key is not set. Please configure it in the settings.");
                    return {};
                }

                return await fetchPricesFromFinnhub(tickers, finnhubKey);
            }

            // Fetch Prices from Alpaca
            async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
                const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
                try {
                    const response = await fetch(url, {
                        headers: {
                            "APCA-API-KEY-ID": apiKey,
                            "APCA-API-SECRET-KEY": apiSecret,
                        },
                    });

                    if (!response.ok) {
                        console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                        return {};
                    }

                    const data = await response.json();
                    const prices = {};

                    for (const [symbol, snapshot] of Object.entries(data)) {
                        prices[symbol] = {
                            price: snapshot.latestTrade?.p || 0,
                            time: snapshot.latestTrade?.t || "N/A",
                            open: snapshot.dailyBar?.o || 0,
                            prevClose: snapshot.prevDailyBar?.c || 0,
                        };
                    }

                    console.log("Fetched prices from Alpaca:", prices);
                    return prices;
                } catch (error) {
                    console.error("Error fetching snapshots from Alpaca:", error);
                    return {};
                }
            }

            // Fetch Prices from Finnhub
            async function fetchPricesFromFinnhub(tickers, apiKey) {
                try {
                    const responses = await Promise.all(
                        tickers.map(async (ticker) => {
                            const [quoteResponse, prevCloseResponse] = await Promise.all([
                                fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                                fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                            ]);

                            if (!quoteResponse.ok) {
                                console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                                return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                            }
                            const quoteData = await quoteResponse.json();

                            let prevClose = 0;
                            if (!prevCloseResponse.ok) {
                                console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                            } else {
                                const prevCloseData = await prevCloseResponse.json();
                                prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                            }

                            return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                        })
                    );

                    const prices = {};
                    responses.forEach((res) => {
                        if (res.ticker) {
                            prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                        }
                    });
                    console.log("Fetched prices from Finnhub:", prices);
                    return prices;
                } catch (error) {
                    console.error("Error fetching prices from Finnhub:", error);
                    return {};
                }
            }

            // Function to Load Portfolio Data
            async function loadPortfolio() {
                allPositions = await fetchPositions();
                // Calculate and append additional fields to each position
                allPositions = allPositions.map(position => {
                    const currentPrice = position.lastPrice || 0;
                    const costBasis = position.avgPrice * position.numShares;
                    const totalValue = currentPrice * position.numShares;
                    const profit = totalValue - costBasis;
                    const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                    const changeToday = position.changeToday || 0;
                    const changePctToday = position.changePctToday || 0;
                    const gapPct = position.gapPct || 0;
                    const timeSinceLastTrade = position.lastTime || "N/A";

                    return {
                        ...position,
                        costBasis,
                        totalValue,
                        profit,
                        profitPct,
                        changeToday,
                        changePctToday,
                        gapPct,
                        timeSinceLastTrade
                    };
                });

                const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
                selectedTickers = selectedTickers.length === 0 ? uniqueTickers : selectedTickers;
                generateFilterCheckboxes(uniqueTickers);
                sortPositions(); // Sort after adding calculated fields
                renderPortfolio();
            }

            // Function to Render Portfolio Table
            async function renderPortfolio() {
                const filteredPositions = filterPositions(allPositions, selectedTickers);
                const portfolioBody = document.getElementById("portfolioBody");
                portfolioBody.innerHTML = "";

                // Render Table Headers Dynamically
                const portfolioHeaders = document.getElementById("portfolioHeaders");
                portfolioHeaders.innerHTML = ""; // Clear existing headers

                visibleColumns.forEach(columnKey => {
                    const header = document.createElement("th");
                    header.setAttribute("data-column", columnKey);
                    header.setAttribute("data-sort-type", getSortType(columnKey));
                    header.setAttribute("data-sort-key", columnKey);
                    header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                    const thName = document.createElement("span");
                    thName.className = "th-name";
                    thName.textContent = getColumnDisplayName(columnKey);

                    const sortArrowAsc = document.createElement("span");
                    sortArrowAsc.className = "sort-arrow asc";
                    sortArrowAsc.textContent = "▲";

                    const sortArrowDesc = document.createElement("span");
                    sortArrowDesc.className = "sort-arrow desc";
                    sortArrowDesc.textContent = "▼";

                    header.appendChild(thName);
                    header.appendChild(sortArrowAsc);
                    header.appendChild(sortArrowDesc);

                    portfolioHeaders.appendChild(header);
                });

                if (filteredPositions.length === 0) {
                    portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                    // Also clear the totals row
                    const totalsRow = document.getElementById("totalsRow");
                    totalsRow.innerHTML = `<td>Totals</td>`;
                    for (let i = 1; i < visibleColumns.length; i++) {
                        totalsRow.innerHTML += `<td></td>`;
                    }
                    return;
                }

                // Fetch batched prices for all symbols
                const uniqueTickers = [...new Set(filteredPositions.map((p) => p.tickerSymbol))];
                const priceData = await fetchCurrentPrices(uniqueTickers);
                console.log("Price Data:", priceData); // Debug log

                let totals = {
                    costBasis: 0,
                    totalValue: 0,
                    profit: 0,
                    profitPct: 0,
                    changeToday: 0,
                    changePctToday: 0,
                    gapPct: 0
                };

                filteredPositions.forEach((position) => {
                    const priceInfo = priceData[position.tickerSymbol] || {};
                    const currentPrice = priceInfo.price || position.lastPrice || 0;
                    const lastTime = priceInfo.time || "N/A";
                    const openPrice = priceInfo.open || position.openPrice || 0;
                    const prevClosePrice = priceInfo.prevClose || position.prevClosePrice || 0;

                    // Update calculated fields
                    position.costBasis = position.avgPrice * position.numShares;
                    position.totalValue = currentPrice * position.numShares;
                    position.profit = position.totalValue - position.costBasis;
                    position.profitPct = position.costBasis !== 0 ? (position.profit / position.costBasis) * 100 : 0;
                    position.changeToday = currentPrice - prevClosePrice;
                    position.changePctToday = prevClosePrice !== 0 ? (position.changeToday / prevClosePrice) * 100 : 0;
                    position.gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                    position.timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                    // Accumulate totals
                    totals.costBasis += position.costBasis;
                    totals.totalValue += position.totalValue;
                    totals.profit += position.profit;
                    totals.profitPct += position.profitPct;
                    totals.changeToday += position.changeToday;
                    totals.changePctToday += position.changePctToday;
                    totals.gapPct += position.gapPct;

                    const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                    // Generate table row based on visibleColumns order
                    let row = `<tr>`;
                    visibleColumns.forEach((columnKey) => {
                        let cellContent = "";
                        switch (columnKey) {
                            case "tickerSymbol":
                                cellContent = position.tickerSymbol;
                                break;
                            case "avgPrice":
                                cellContent = position.avgPrice.toFixed(2);
                                break;
                            case "numShares":
                                cellContent = position.numShares;
                                break;
                            case "lastPrice":
                                cellContent = currentPrice.toFixed(2);
                                break;
                            case "costBasis":
                                cellContent = position.costBasis.toFixed(2);
                                break;
                            case "totalValue":
                                cellContent = position.totalValue.toFixed(2);
                                break;
                            case "profit":
                                cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                                break;
                            case "profitPct":
                                cellContent = `${position.profitPct.toFixed(2)}%`;
                                break;
                            case "changeToday":
                                cellContent = position.changeToday.toFixed(2);
                                break;
                            case "changePctToday":
                                cellContent = `${position.changePctToday.toFixed(2)}%`;
                                break;
                            case "gapPct":
                                cellContent = `${position.gapPct.toFixed(2)}%`;
                                break;
                            case "lastTime":
                                cellContent = position.timeSinceLastTrade;
                                break;
                            default:
                                cellContent = "";
                        }
                        row += `<td>${cellContent}</td>`;
                    });
                    row += `</tr>`;
                    portfolioBody.innerHTML += row;
                });

                // Calculate total profit percentage based on total cost basis
                const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

                // Update totals in the footer based on visibleColumns
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = `<td>Totals</td>`;

                visibleColumns.forEach((columnKey) => {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                });

                // If there are remaining columns not handled, fill them with empty cells
                const totalColumns = 12; // Total number of possible columns
                if (visibleColumns.length < totalColumns) {
                    for (let i = visibleColumns.length; i < totalColumns; i++) {
                        totalsRow.innerHTML += `<td></td>`;
                    }
                }
            }

            // Function to Get Sort Type Based on Column Key
            function getSortType(columnKey) {
                const stringColumns = ["tickerSymbol", "lastTime"];
                if (stringColumns.includes(columnKey)) {
                    return "string";
                }
                return "number";
            }

            // Function to Get Display Name for Column
            function getColumnDisplayName(columnKey) {
                const mapping = {
                    "tickerSymbol": "Ticker",
                    "avgPrice": "Average Price",
                    "numShares": "Shares",
                    "lastPrice": "Current Price",
                    "costBasis": "Cost Basis",
                    "totalValue": "Total Value",
                    "profit": "Profit",
                    "profitPct": "Profit %",
                    "changeToday": "Change Today",
                    "changePctToday": "Change % Today",
                    "gapPct": "Gap %",
                    "lastTime": "Time Since Last Trade"
                };
                return mapping[columnKey] || columnKey;
            }

            // Function to Calculate Time Since Last Trade
            function calculateTimeSinceLastTrade(lastTradeTime) {
                if (lastTradeTime === "N/A") return "N/A";
                const lastTradeDate = new Date(lastTradeTime);
                const now = new Date();
                const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

                if (diffInSeconds < 60) {
                    return `${diffInSeconds}s ago`;
                } else if (diffInSeconds < 3600) {
                    const minutes = Math.round(diffInSeconds / 60);
                    return `${minutes}m ago`;
                } else if (diffInSeconds < 86400) {
                    const hours = Math.round(diffInSeconds / 3600);
                    return `${hours}h ago`;
                } else {
                    const days = Math.round(diffInSeconds / 86400);
                    return `${days}d ago`;
                }
            }

            // Function to Fetch All Positions from IndexedDB
            async function fetchPositions() {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readonly");
                const store = transaction.objectStore(positionsStoreName);

                return new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            // Function to Update a Position in IndexedDB
            async function updatePosition(tickerSymbol, currentPrice, lastTime, openPrice, prevClosePrice) {
                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readwrite");
                const store = transaction.objectStore(positionsStoreName);

                const position = await new Promise((resolve, reject) => {
                    const request = store.get(tickerSymbol);
                    request.onsuccess = (event) => resolve(event.target.result);
                    request.onerror = (event) => reject(event.target.error);
                });

                if (position) {
                    position.lastPrice = currentPrice;
                    position.lastTime = lastTime;
                    position.openPrice = openPrice;
                    position.prevClosePrice = prevClosePrice;
                    store.put(position);
                }
            }

            // Function to Start Auto-Refresh
            async function startAutoRefresh() {
                const interval = await getRefreshInterval();
                if (refreshIntervalId) {
                    clearInterval(refreshIntervalId);
                }

                if (interval > 0) {
                    refreshIntervalId = setInterval(async () => {
                        console.log("Auto-refreshing prices...");
                        await loadPortfolio(); // Changed to loadPortfolio to recalculate and sort
                    }, interval * 1000);
                }
            }

            // Function to Get Refresh Interval from IndexedDB
            async function getRefreshInterval() {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                return new Promise((resolve, reject) => {
                    const request = store.get("refreshInterval");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                    request.onerror = (event) => reject(event.target.error);
                });
            }

            // Function to Generate Filter Checkboxes
            function generateFilterCheckboxes(uniqueTickers) {
                const filterCheckboxes = document.getElementById("filterCheckboxes");
                filterCheckboxes.innerHTML = "";

                uniqueTickers.forEach((ticker) => {
                    const isChecked = selectedTickers.includes(ticker);
                    const checkbox = document.createElement("div");
                    checkbox.className = "form-check form-check-inline filter-checkbox";
                    checkbox.innerHTML = `
                        <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" ${isChecked ? "checked" : ""}>
                        <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                    `;

                    checkbox.addEventListener("change", () => {
                        const ticker = checkbox.querySelector("input").value;
                        if (checkbox.querySelector("input").checked) {
                            if (!selectedTickers.includes(ticker)) {
                                selectedTickers.push(ticker);
                            }
                        } else {
                            selectedTickers = selectedTickers.filter((t) => t !== ticker);
                        }
                        sortPositions(); // Re-sort after filter change
                        renderPortfolio();
                    });

                    filterCheckboxes.appendChild(checkbox);
                });
            }

            // Function to Filter Positions Based on Selected Tickers and Filter Text
            function filterPositions(positions, selectedTickers) {
                const filterInput = document.getElementById("filterInput");
                const filterText = filterInput.value.toLowerCase();
                return positions.filter((position) => {
                    const tickerMatches = position.tickerSymbol.toLowerCase().includes(filterText);
                    const isSelected = selectedTickers.includes(position.tickerSymbol);
                    return tickerMatches && isSelected;
                });
            }

            // Function to Save API Keys to IndexedDB
            async function saveKeys(alpacaKey, alpacaSecret, finnhubKey) {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                appendDebugLog("Saving API keys...");

                if (alpacaKey) {
                    store.put({ key: "APCA_API_KEY_ID", value: alpacaKey });
                    appendDebugLog(`Alpaca Key saved: ${alpacaKey}`);
                }

                if (alpacaSecret) {
                    store.put({ key: "APCA_API_SECRET_KEY", value: alpacaSecret });
                    appendDebugLog("Alpaca Secret saved.");
                }

                if (finnhubKey) {
                    store.put({ key: "finnhubApiKey", value: finnhubKey });
                    appendDebugLog("Finnhub Key saved.");
                }

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => {
                        appendDebugLog("Settings saved successfully.");
                        resolve();
                    };

                    transaction.onerror = (event) => {
                        appendDebugLog(`Failed to save settings: ${event.target.error}`);
                        reject(event.target.error);
                    };
                });
            }

            // Function to Show Feedback Messages
            function showFeedback(message, type) {
                const feedbackDiv = document.getElementById("settingsFeedback");
                feedbackDiv.textContent = message;
                feedbackDiv.className = `mt-2 text-${type}`;
                feedbackDiv.style.display = "block";

                setTimeout(() => {
                    feedbackDiv.style.display = "none";
                }, 3000);
            }

            // Function to Save Refresh Interval to IndexedDB
            async function saveRefreshInterval(interval) {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                store.put({ key: "refreshInterval", value: interval });

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => {
                        console.log("Refresh interval saved successfully!");
                        resolve();
                    };
                    transaction.onerror = (event) => {
                        console.error("Failed to save refresh interval.", event.target.error);
                        reject(event.target.error);
                    };
                });
            }

            // Function to Load Saved Refresh Interval
            async function loadSavedRefreshInterval() {
                const interval = await getRefreshInterval();
                const refreshButtons = document.querySelectorAll(".refresh-interval-button");

                refreshButtons.forEach((button) => {
                    if (parseInt(button.getAttribute("data-interval")) === interval) {
                        button.classList.add("btn-primary");
                    } else {
                        button.classList.remove("btn-primary");
                    }
                });
            }

            // Function to Append Messages to Debug Logs
            function appendDebugLog(message) {
                const debugDiv = document.getElementById("debugLogs");
                const log = document.createElement("div");
                log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                debugDiv.appendChild(log);
                debugDiv.style.display = "block"; // Make sure it's visible if needed
            }

            // Function to Setup Column Customization (Visibility and Ordering)
            function setupColumnCustomization() {
                const sortableColumns = document.getElementById("sortableColumns");
                const columnCheckboxes = document.querySelectorAll("#columnCustomization .column-checkbox");
                const columnItems = document.querySelectorAll("#sortableColumns .column-item");

                let draggedItem = null;

                // Drag Start Event
                sortableColumns.addEventListener("dragstart", (event) => {
                    draggedItem = event.target.closest(".column-item");
                    if (draggedItem) {
                        event.dataTransfer.effectAllowed = "move";
                        event.dataTransfer.setData("text/plain", "");
                        setTimeout(() => {
                            draggedItem.classList.add("dragging");
                        }, 0);
                    }
                });

                // Drag Over Event
                sortableColumns.addEventListener("dragover", (event) => {
                    event.preventDefault();
                    const targetItem = event.target.closest(".column-item");
                    if (targetItem && targetItem !== draggedItem) {
                        const bounding = targetItem.getBoundingClientRect();
                        const offset = bounding.y + bounding.height / 2;

                        if (event.clientY - offset > 0) {
                            targetItem.style.borderBottom = "2px solid white";
                            targetItem.style.borderTop = "";
                        } else {
                            targetItem.style.borderTop = "2px solid white";
                            targetItem.style.borderBottom = "";
                        }
                    }
                });

                // Drag Leave Event
                sortableColumns.addEventListener("dragleave", (event) => {
                    const targetItem = event.target.closest(".column-item");
                    if (targetItem) {
                        targetItem.style.borderTop = "";
                        targetItem.style.borderBottom = "";
                    }
                });

                // Drop Event
                sortableColumns.addEventListener("drop", async (event) => {
                    event.preventDefault();
                    const targetItem = event.target.closest(".column-item");
                    if (draggedItem && targetItem) {
                        if (draggedItem !== targetItem) {
                            if (targetItem.style.borderBottom === "2px solid white") {
                                sortableColumns.insertBefore(draggedItem, targetItem.nextSibling);
                            } else {
                                sortableColumns.insertBefore(draggedItem, targetItem);
                            }
                            targetItem.style.borderTop = "";
                            targetItem.style.borderBottom = "";
                            draggedItem.classList.remove("dragging");
                            draggedItem = null;

                            // Update visibleColumns based on new order
                            await updateVisibleColumns();
                            renderPortfolio();
                        }
                    }
                });

                // Checkbox Change Events
                columnCheckboxes.forEach((checkbox) => {
                    checkbox.addEventListener("change", async () => {
                        const columnKey = checkbox.value;
                        if (checkbox.checked) {
                            if (!visibleColumns.includes(columnKey)) {
                                // Find the position to insert based on current sortableColumns order
                                const sortableColumnItems = document.querySelectorAll("#sortableColumns .column-item");
                                let insertIndex = sortableColumnItems.length; // Default to end
                                sortableColumnItems.forEach((item, index) => {
                                    if (item.getAttribute("data-column") === columnKey) {
                                        insertIndex = index;
                                    }
                                });
                                visibleColumns.splice(insertIndex, 0, columnKey);
                            }
                        } else {
                            visibleColumns = visibleColumns.filter((key) => key !== columnKey);
                        }
                        await saveVisibleColumns();
                        renderPortfolio();
                    });
                });
            }

            // Function to Save Visible Columns to IndexedDB
            async function saveVisibleColumns() {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                const sortedColumnItems = document.querySelectorAll("#sortableColumns .column-item");
                const updatedVisibleColumns = Array.from(sortedColumnItems)
                    .map(item => item.getAttribute("data-column"))
                    .filter(column => visibleColumns.includes(column));

                store.put({ key: "visibleColumns", value: updatedVisibleColumns });

                return new Promise((resolve, reject) => {
                    transaction.oncomplete = () => {
                        console.log("Visible columns saved successfully!");
                        resolve();
                    };
                    transaction.onerror = (event) => {
                        console.error("Failed to save visible columns.", event.target.error);
                        reject(event.target.error);
                    };
                });
            }

            // Function to Load Saved Visible Columns from IndexedDB
            async function loadSavedVisibleColumns() {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                return new Promise((resolve, reject) => {
                    const request = store.get("visibleColumns");
                    request.onsuccess = (event) => {
                        const savedVisibleColumns = event.target.result?.value;
                        if (savedVisibleColumns && Array.isArray(savedVisibleColumns)) {
                            visibleColumns = savedVisibleColumns;
                            updateCheckboxes();
                            updateSortableColumns(); // Ensure sortableColumns reflect the saved order
                        }
                        resolve();
                    };
                    request.onerror = (event) => {
                        console.error("Failed to load visible columns.", event.target.error);
                        reject(event.target.error);
                    };
                });
            }

            // Function to Update Checkboxes Based on visibleColumns
            function updateCheckboxes() {
                const columnCheckboxes = document.querySelectorAll("#columnCustomization .column-checkbox");
                columnCheckboxes.forEach((checkbox) => {
                    checkbox.checked = visibleColumns.includes(checkbox.value);
                });
            }

            // Function to Update Sortable Columns Order in DOM
            function updateSortableColumns() {
                const sortableColumns = document.getElementById("sortableColumns");
                sortableColumns.innerHTML = ""; // Clear existing sortable columns

                visibleColumns.forEach(columnKey => {
                    const columnItem = document.querySelector(`.column-item[data-column="${columnKey}"]`);
                    if (columnItem) {
                        sortableColumns.appendChild(columnItem);
                    }
                });
            }

            // Function to Sort Positions Based on sortColumn and sortDirection
            function sortPositions() {
                if (!sortColumn) return;

                allPositions.sort((a, b) => {
                    let valA = a[sortColumn];
                    let valB = b[sortColumn];

                    // Handle undefined or null values
                    valA = valA !== undefined && valA !== null ? valA : (typeof valB === 'number' ? -Infinity : '');
                    valB = valB !== undefined && valB !== null ? valB : (typeof valA === 'number' ? -Infinity : '');

                    // If sorting by string, convert to lowercase for case-insensitive comparison
                    if (typeof valA === 'string') {
                        valA = valA.toLowerCase();
                        valB = typeof valB === 'string' ? valB.toLowerCase() : '';
                    }

                    if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                    if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                });
            }

            // Function to Update Visible Columns Array Based on DOM Order
            async function updateVisibleColumns() {
                const columnItems = document.querySelectorAll("#sortableColumns .column-item");
                const newVisibleColumns = [];

                columnItems.forEach(item => {
                    const columnKey = item.getAttribute("data-column");
                    if (visibleColumns.includes(columnKey)) {
                        newVisibleColumns.push(columnKey);
                    }
                });

                visibleColumns = newVisibleColumns;
                await saveVisibleColumns();
            }

            // Function to Setup Event Listeners on DOMContentLoaded
            document.addEventListener("DOMContentLoaded", async () => {
                const settingsIcon = document.getElementById("settingsIcon");
                const settingsSection = document.getElementById("settings");

                // Toggle Settings Section
                settingsIcon.addEventListener("click", () => {
                    if (settingsSection.style.display === "none" || !settingsSection.style.display) {
                        settingsSection.style.display = "block";
                    } else {
                        settingsSection.style.display = "none";
                    }
                });

                // Setup Refresh Interval Buttons
                const refreshButtons = document.querySelectorAll(".refresh-interval-button");

                refreshButtons.forEach((button) => {
                    button.addEventListener("click", async (event) => {
                        const selectedInterval = parseInt(event.target.getAttribute("data-interval"));
                        await saveRefreshInterval(selectedInterval);

                        refreshButtons.forEach((btn) => btn.classList.remove("btn-primary"));
                        event.target.classList.add("btn-primary");

                        startAutoRefresh();
                    });
                });

                // Setup Save Keys Button
                const saveKeysButton = document.getElementById("saveKeys");
                saveKeysButton.addEventListener("click", async () => {
                    const alpacaKey = document.getElementById("alpacaApiKey").value;
                    const alpacaSecret = document.getElementById("alpacaApiSecret").value;
                    const finnhubKey = document.getElementById("finnhubApiKey").value;

                    try {
                        await saveKeys(alpacaKey, alpacaSecret, finnhubKey);
                        showFeedback("Settings saved successfully!", "success");
                    } catch (error) {
                        console.error("Failed to save settings:", error);
                        showFeedback("Failed to save settings.", "danger");
                    }
                });

                // Setup Table Header Click Events for Sorting
                document.addEventListener("click", (event) => {
                    const th = event.target.closest("th");
                    if (!th) return;

                    const newSortColumn = th.getAttribute("data-sort-key");
                    const sortType = th.getAttribute("data-sort-type");

                    if (sortColumn === newSortColumn) {
                        sortDirection = sortDirection === "asc" ? "desc" : "asc";
                    } else {
                        sortColumn = newSortColumn;
                        sortDirection = "asc";
                    }

                    // Remove sort classes from all headers
                    const allTh = document.querySelectorAll("#portfolioHeaders th");
                    allTh.forEach((header) => {
                        header.classList.remove("sorted-asc", "sorted-desc");
                    });

                    // Add sort class to the current header
                    th.classList.add(sortDirection === "asc" ? "sorted-asc" : "sorted-desc");

                    sortPositions();
                    renderPortfolio();
                });

                // Setup Filter Input Event
                const filterInput = document.getElementById("filterInput");
                filterInput.addEventListener("input", () => {
                    sortPositions(); // Re-sort when filter changes
                    renderPortfolio();
                });

                // Load Saved Settings
                await loadSavedVisibleColumns();
                await loadSavedRefreshInterval();

                // Load Portfolio Data and Start Auto-Refresh
                await loadPortfolio();
                await startAutoRefresh();

                // Setup Column Customization (Visibility and Ordering)
                setupColumnCustomization();
            });

            // Function to Append Messages to Debug Logs
            function appendDebugLog(message) {
                const debugDiv = document.getElementById("debugLogs");
                const log = document.createElement("div");
                log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
                debugDiv.appendChild(log);
                debugDiv.style.display = "block"; // Make sure it's visible if needed
            }
        </script>
    </body>
</html>