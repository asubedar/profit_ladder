<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
            position: relative;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            margin-top: 20px;
            background-color: #1e1e1e;
            padding: 20px;
            border-radius: 5px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 60px;
            height: 40px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #cccccc;
        }
        .th-name {
            margin-left: 25px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
        /* Debug Logs Styling */
        #debugLogs {
            background-color: #1e1e1e;
            padding: 10px;
            border: 1px solid #444;
            max-height: 200px;
            overflow-y: auto;
            margin-top: 20px;
            display: block;
        }
        /* Customize Columns Styling */
        #sortableColumns .column-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            cursor: grab;
            padding: 5px 10px;
            background-color: #1e1e1e;
            border: 1px solid #444;
            color: #ffffff;
            margin-bottom: 5px;
            border-radius: 4px;
        }
        #sortableColumns .column-item.dragging {
            opacity: 0.5;
        }
        /* Checkbox and Label Styling */
        #sortableColumns .form-check-input {
            accent-color: #00bcd4;
        }
        #sortableColumns .form-check-label {
            margin-left: 5px;
        }
        /* Active Refresh Interval Button Styling */
        .refresh-interval-button.active {
            background-color: #00bcd4;
            color: #fff;
        }
        /* Reset Database Button Styling */
        .reset-db-button {
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <!-- Navigation Bar -->
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>

    <!-- Main Container -->
    <div class="container">
        <!-- Filter Section -->
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>

        <!-- Portfolio Table -->
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr id="portfolioHeaders">
                        <!-- Dynamic Headers will be inserted here -->
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row" id="totalsRow">
                        <!-- Totals will be inserted here -->
                    </tr>
                </tfoot>
            </table>
        </div>

        <!-- Auto-Refresh Interval Section -->
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>

        <!-- Settings Toggle -->
        <div class="settings-toggle text-end mt-4">
            <span id="settingsIcon"><i class="fas fa-cog"></i> Settings</span>
        </div>

        <!-- Settings Section -->
        <div class="settings d-none" id="settings">
            <h3>Settings</h3>
            <!-- Column Customization -->
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" class="list-group">
                    <!-- List items will be populated dynamically by JavaScript -->
                </ul>
                <button id="resetSettings" class="btn btn-secondary mt-3">Reset to Default</button>
            </div>

            <!-- API Keys Section -->
            <div class="mb-3">
                <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
                <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            </div>
            <div class="mb-3">
                <label for="alpacaApiSecret" class="form-label">Alpaca API Secret:</label>
                <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            </div>
            <div class="mb-3">
                <label for="finnhubApiKey" class="form-label">Finnhub API Key:</label>
                <input type="text" id="finnhubApiKey" class="form-control" placeholder="Enter your Finnhub API Key">
            </div>
            <button id="saveKeys" class="btn btn-primary">Save Settings</button>

            <!-- Reset Database Button -->
            <button id="resetDatabase" class="btn btn-danger reset-db-button">
                <i class="fas fa-database"></i> Reset Database
            </button>
        </div>

        <!-- Debug Logs Section -->
        <div id="debugLogs"></div>
    </div>

    <!-- Bootstrap JS and Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <!-- Font Awesome JS for Icons -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/js/all.min.js"></script>
    <!-- Main JavaScript -->
    <script>
        // Database Configuration
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        // State Variables
        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let visibleColumns = [
            "tickerSymbol",
            "avgPrice",
            "numShares",
            "lastPrice",
            "costBasis",
            "totalValue",
            "profit",
            "profitPct",
            "changeToday",
            "changePctToday",
            "gapPct",
            "lastTime"
        ];

        // Define the available columns
        const availableColumns = [
            { key: "tickerSymbol", name: "Ticker" },
            { key: "avgPrice", name: "Average Price" },
            { key: "numShares", name: "Shares" },
            { key: "lastPrice", name: "Current Price" },
            { key: "costBasis", name: "Cost Basis" },
            { key: "totalValue", name: "Total Value" },
            { key: "profit", name: "Profit" },
            { key: "profitPct", name: "Profit %" },
            { key: "changeToday", name: "Change Today" },
            { key: "changePctToday", name: "Change % Today" },
            { key: "gapPct", name: "Gap %" },
            { key: "lastTime", name: "Time Since Last Trade" }
        ];

        // Function to Append Debug Logs
        function appendDebugLog(message) {
            const debugLogs = document.getElementById("debugLogs");
            const logEntry = document.createElement("div");
            logEntry.textContent = message;
            debugLogs.appendChild(logEntry);
        }

        // Function to Populate Sortable Columns
        function populateSortableColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            sortableColumns.innerHTML = ""; // Clear existing list items

            // First, add columns in the order of visibleColumns
            visibleColumns.forEach(columnKey => {
                const column = availableColumns.find(col => col.key === columnKey);
                if (column) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Then, add the remaining columns not in visibleColumns
            availableColumns.forEach(column => {
                if (!visibleColumns.includes(column.key)) {
                    const li = createColumnListItem(column);
                    sortableColumns.appendChild(li);
                }
            });

            // Initialize Drag-and-Drop Functionality
            initializeDragAndDrop();

            console.log("Sortable columns populated successfully.");
            appendDebugLog("Sortable columns populated successfully.");
        }

        // Helper Function to Create a Column List Item
        function createColumnListItem(column) {
            const li = document.createElement("li");
            li.className = "column-item list-group-item d-flex align-items-center";
            li.setAttribute("data-column", column.key);
            li.setAttribute("draggable", "true");

            li.innerHTML = `
                <span class="drag-handle me-2"><i class="fas fa-grip-vertical"></i></span>
                <div class="form-check">
                    <input class="form-check-input column-checkbox me-2" type="checkbox" id="checkbox-${column.key}" value="${column.key}" ${visibleColumns.includes(column.key) ? "checked" : ""}>
                    <label class="form-check-label text-light" for="checkbox-${column.key}">${column.name}</label>
                </div>
            `;

            // Add Event Listener for Checkbox Change
            li.querySelector('.column-checkbox').addEventListener('change', () => {
                updateVisibleColumns();
                renderPortfolio();
            });

            return li;
        }

        // Function to Initialize Drag-and-Drop for Sortable Columns
        function initializeDragAndDrop() {
            const sortableColumns = document.getElementById("sortableColumns");
            let dragSrcEl = null;

            function handleDragStart(e) {
                dragSrcEl = this;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', null); // For Firefox compatibility
                this.classList.add('dragging');
            }

            function handleDragOver(e) {
                if (e.preventDefault) {
                    e.preventDefault(); // Necessary to allow drop
                }
                e.dataTransfer.dropEffect = 'move'; // Show move cursor
                return false;
            }

            function handleDragEnter(e) {
                this.classList.add('over');
            }

            function handleDragLeave(e) {
                this.classList.remove('over');
            }

            function handleDrop(e) {
                if (e.stopPropagation) {
                    e.stopPropagation(); // Stops the browser from redirecting.
                }

                if (dragSrcEl !== this) {
                    // Reorder the DOM elements by inserting the dragged element before the drop target
                    sortableColumns.insertBefore(dragSrcEl, this);

                    // Update visibleColumns based on new order
                    updateVisibleColumns();
                    renderPortfolio();
                }
                return false;
            }

            function handleDragEnd(e) {
                this.classList.remove('dragging');
                const items = sortableColumns.querySelectorAll('.column-item');
                items.forEach(function (item) {
                    item.classList.remove('over');
                });
            }

            function addDnDHandlers(elem) {
                elem.addEventListener('dragstart', handleDragStart, false);
                elem.addEventListener('dragenter', handleDragEnter, false);
                elem.addEventListener('dragover', handleDragOver, false);
                elem.addEventListener('dragleave', handleDragLeave, false);
                elem.addEventListener('drop', handleDrop, false);
                elem.addEventListener('dragend', handleDragEnd, false);
            }

            const items = sortableColumns.querySelectorAll('.column-item');
            items.forEach(function(item) {
                addDnDHandlers(item);
            });
        }

        // Function to Update Visible Columns Order and Visibility Based on Column Settings
        async function updateVisibleColumns() {
            const sortableColumns = document.getElementById("sortableColumns");
            const columnItems = sortableColumns.querySelectorAll('.column-item');
            visibleColumns = Array.from(columnItems)
                .filter(item => item.querySelector('.column-checkbox').checked)
                .map(item => item.getAttribute('data-column'));

            // Ensure uniqueness to prevent duplicate columns
            visibleColumns = [...new Set(visibleColumns)];

            console.log("Updated visibleColumns:", visibleColumns);
            appendDebugLog("Updated visibleColumns.");

            // Save visibleColumns to IndexedDB
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "visibleColumns", value: visibleColumns });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });
                appendDebugLog("Visible columns saved to settings.");
            } catch (error) {
                console.error("Error saving visible columns:", error);
                appendDebugLog(`Error saving visible columns: ${error}`);
            }
        }

        // Function to Load Portfolio Data
        async function loadPortfolio() {
            allPositions = await fetchVisiblePositions();
            // Calculate and append additional fields to each position
            allPositions = allPositions.map(position => {
                const currentPrice = position.lastPrice || 0;
                const costBasis = position.avgPrice * position.numShares;
                const totalValue = currentPrice * position.numShares;
                const profit = totalValue - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = position.changeToday || 0;
                const changePctToday = position.changePctToday || 0;
                const gapPct = position.gapPct || 0;
                const timeSinceLastTrade = position.lastTime || "N/A";

                return {
                    ...position,
                    costBasis,
                    totalValue,
                    profit,
                    profitPct,
                    changeToday,
                    changePctToday,
                    gapPct,
                    timeSinceLastTrade
                };
            });

            // Fetch all unique tickers, including hidden ones
            const uniqueTickers = await fetchAllTickers();
            await generateFilterCheckboxes(uniqueTickers);
            renderPortfolio();
        }

        // Function to Render Portfolio Table
        async function renderPortfolio() {
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            // Render Table Headers Dynamically
            const portfolioHeaders = document.getElementById("portfolioHeaders");
            portfolioHeaders.innerHTML = ""; // Clear existing headers

            visibleColumns.forEach(columnKey => {
                const header = document.createElement("th");
                header.setAttribute("data-column", columnKey);
                header.setAttribute("data-sort-type", getSortType(columnKey));
                header.setAttribute("data-sort-key", columnKey);
                header.setAttribute("data-col-index", visibleColumns.indexOf(columnKey));

                const thName = document.createElement("span");
                thName.className = "th-name";
                thName.textContent = getColumnDisplayName(columnKey);

                const sortArrowAsc = document.createElement("span");
                sortArrowAsc.className = "sort-arrow asc";
                sortArrowAsc.textContent = "▲";

                const sortArrowDesc = document.createElement("span");
                sortArrowDesc.className = "sort-arrow desc";
                sortArrowDesc.textContent = "▼";

                header.appendChild(thName);
                header.appendChild(sortArrowAsc);
                header.appendChild(sortArrowDesc);

                // Add Event Listener for Sorting
                header.addEventListener('click', () => {
                    if (sortColumn === columnKey) {
                        sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
                    } else {
                        sortColumn = columnKey;
                        sortDirection = 'asc';
                    }
                    updateSortSettings(sortColumn, sortDirection);
                    sortPositions();
                    renderPortfolio();
                });

                // Update sorted class
                if (sortColumn === columnKey) {
                    header.classList.add(sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc');
                } else {
                    header.classList.remove('sorted-asc', 'sorted-desc');
                }

                portfolioHeaders.appendChild(header);
            });

            // Fetch updated positions from IndexedDB
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const updatedPositions = await new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });

            // Update allPositions with the fresh data from the database
            allPositions = updatedPositions;

            if (allPositions.length === 0) {
                portfolioBody.innerHTML = `<tr><td colspan="${visibleColumns.length}" class="text-center">No positions to display.</td></tr>`;
                // Also clear the totals row
                const totalsRow = document.getElementById("totalsRow");
                totalsRow.innerHTML = ``;
                return;
            }

            let totals = {
                costBasis: 0,
                totalValue: 0,
                profit: 0,
                profitPct: 0,
                changeToday: 0,
                changePctToday: 0,
                gapPct: 0
            };

            // Create a new array for rendering
            const positionsToRender = updatedPositions.map(position => {
                const currentPrice = position.lastPrice || 0;
                const lastTime = position.lastTime || "N/A";
                const openPrice = position.openPrice || 0;
                const prevClosePrice = position.prevClosePrice || 0;

                // Calculate derived fields
                const costBasis = position.avgPrice * position.numShares;
                const totalValue = currentPrice * position.numShares;
                const profit = totalValue - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = currentPrice - prevClosePrice;
                const changePctToday = prevClosePrice !== 0 ? (changeToday / prevClosePrice) * 100 : 0;
                const gapPct = prevClosePrice !== 0 ? ((currentPrice - openPrice) / prevClosePrice) * 100 : 0;
                const timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                // Accumulate totals
                totals.costBasis += costBasis;
                totals.totalValue += totalValue;
                totals.profit += profit;
                totals.profitPct += profitPct;
                totals.changeToday += changeToday;
                totals.changePctToday += changePctToday;
                totals.gapPct += gapPct;

                return {
                    ...position,
                    costBasis,
                    totalValue,
                    profit,
                    profitPct,
                    changeToday,
                    changePctToday,
                    gapPct,
                    timeSinceLastTrade
                };
            });

            // Sort the positions to render
            sortPositions();

            // Render the table rows using the new array
            positionsToRender.forEach(position => {
                const profitClass = position.profit >= 0 ? "profit-positive" : "profit-negative";

                // Generate table row based on visibleColumns order
                let row = `<tr>`;
                visibleColumns.forEach((columnKey) => {
                    let cellContent = "";
                    switch (columnKey) {
                        case "tickerSymbol":
                            cellContent = position.tickerSymbol;
                            break;
                        case "avgPrice":
                            cellContent = position.avgPrice.toFixed(2);
                            break;
                        case "numShares":
                            cellContent = position.numShares;
                            break;
                        case "lastPrice":
                            cellContent = position.lastPrice.toFixed(2);
                            break;
                        case "costBasis":
                            cellContent = position.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            cellContent = position.totalValue.toFixed(2);
                            break;
                        case "profit":
                            cellContent = `<span class="${profitClass}">${position.profit.toFixed(2)}</span>`;
                            break;
                        case "profitPct":
                            cellContent = `${position.profitPct.toFixed(2)}%`;
                            break;
                        case "changeToday":
                            cellContent = position.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            cellContent = `${position.changePctToday.toFixed(2)}%`;
                            break;
                        case "gapPct":
                            cellContent = `${position.gapPct.toFixed(2)}%`;
                            break;
                        case "lastTime":
                            cellContent = position.timeSinceLastTrade;
                            break;
                        default:
                            cellContent = "";
                    }
                    row += `<td>${cellContent}</td>`;
                });
                row += `</tr>`;
                portfolioBody.innerHTML += row;
            });

            // Calculate total profit percentage based on total cost basis
            const totalProfitPct = totals.costBasis !== 0 ? (totals.profit / totals.costBasis) * 100 : 0;

            // Update totals in the footer based on visibleColumns
            const totalsRow = document.getElementById("totalsRow");
            totalsRow.innerHTML = ""; // Clear existing cells

            visibleColumns.forEach(columnKey => {
                if (columnKey === "tickerSymbol") {
                    totalsRow.innerHTML += `<td>Totals</td>`;
                } else {
                    let footerContent = "";
                    switch (columnKey) {
                        case "costBasis":
                            footerContent = totals.costBasis.toFixed(2);
                            break;
                        case "totalValue":
                            footerContent = totals.totalValue.toFixed(2);
                            break;
                        case "profit":
                            footerContent = totals.profit.toFixed(2);
                            break;
                        case "profitPct":
                            footerContent = totalProfitPct.toFixed(2) + "%";
                            break;
                        case "changeToday":
                            footerContent = totals.changeToday.toFixed(2);
                            break;
                        case "changePctToday":
                            footerContent = totals.changePctToday.toFixed(2) + "%";
                            break;
                        case "gapPct":
                            footerContent = totals.gapPct.toFixed(2) + "%";
                            break;
                        default:
                            footerContent = ""; // Empty for other columns
                    }
                    totalsRow.innerHTML += `<td>${footerContent}</td>`;
                }
            });
        }

        // Function to Get Sort Type Based on Column Key
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        // Function to Get Display Name for Column
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        // Function to Calculate Time Since Last Trade
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        // Function to Sort Positions
        function sortPositions() {
            if (!sortColumn) return;

            // Sort the updated positions based on the selected column and direction
            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                if (getSortType(sortColumn) === "string") {
                    valA = (valA || "").toUpperCase(); // Handle undefined or null
                    valB = (valB || "").toUpperCase(); // Handle undefined or null
                    return sortDirection === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                } else {
                    valA = valA || 0; // Handle undefined or null
                    valB = valB || 0; // Handle undefined or null
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
            });
            // Persist sort settings to IndexedDB
            updateSortSettings(sortColumn, sortDirection);
        }
        
        // Function to update sort settings in IndexedDB
        async function updateSortSettings(column, direction) {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readwrite");
                const store = transaction.objectStore(settingsStoreName);

                // Store sort column
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "sortColumn", value: column });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });

                // Store sort direction
                await new Promise((resolve, reject) => {
                    const request = store.put({ key: "sortDirection", value: direction });
                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(event.target.error);
                });

                appendDebugLog(`Sort settings updated: column=${column}, direction=${direction}`);
            } catch (error) {
                console.error("Error updating sort settings:", error);
                appendDebugLog(`Error updating sort settings: ${error}`);
            }
        }

        // Function to Fetch Visible Positions from IndexedDB
        async function fetchVisiblePositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => {
                    const all = event.target.result;
                    // Filter out positions where hide is true
                    const visible = all.filter(position => !position.hide);
                    resolve(visible);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch All Unique Tickers from IndexedDB
        async function fetchAllTickers() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index.openCursor(null, "nextunique");
                const tickers = [];
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        tickers.push(cursor.key);
                        cursor.continue();
                    } else {
                        resolve(tickers);
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Generate Filter Checkboxes
        async function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            const db = await openDatabase();
            const store = db.transaction(positionsStoreName, "readonly").objectStore(positionsStoreName);

            for (const ticker of uniqueTickers) {
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" checked>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                // Determine the initial checked state based on positions' hide attribute
                const request = store.index && store.index("tickerSymbol") ? store.index("tickerSymbol").getAll(ticker) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === ticker);
                    const isHidden = positions.every(pos => pos.hide);
                    if (isHidden) {
                        checkbox.querySelector('input').checked = false;
                    } else {
                        checkbox.querySelector('input').checked = true;
                    }
                };
                request.onerror = (event) => {
                    console.error(`Error fetching positions for ${ticker}:`, event.target.error);
                };

                // Add Event Listener for Checkbox Change
                checkbox.querySelector('input').addEventListener("change", async () => {
                    const ticker = checkbox.querySelector("input").value;
                    const isChecked = checkbox.querySelector("input").checked;
                    const hide = !isChecked;

                    // Update the 'hide' attribute for all positions with this tickerSymbol
                    try {
                        await setHideForTickerSymbol(ticker, hide);
                        console.log(`Set hide=${hide} for tickerSymbol=${ticker}`);
                        appendDebugLog(`Set hide=${hide} for tickerSymbol=${ticker}`);

                        // Reload portfolio after updating hide status
                        await loadPortfolio();
                    } catch (error) {
                        console.error(`Error setting hide for tickerSymbol=${ticker}:`, error);
                        appendDebugLog(`Error setting hide for tickerSymbol=${ticker}: ${error}`);
                    }
                });

                filterCheckboxes.appendChild(checkbox);
            }
        }

        // Function to Update the 'hide' Attribute for All Positions with a Specific Ticker Symbol
        async function setHideForTickerSymbol(tickerSymbol, hide) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index ? index.getAll(tickerSymbol) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === tickerSymbol);
                    for (const position of positions) {
                        position.hide = hide;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    resolve();
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch Current Prices
        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            const alpacaKey = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_KEY_ID");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            const alpacaSecret = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_SECRET_KEY");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (alpacaKey && alpacaSecret) {
                return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
            }

            console.warn("Alpaca credentials not available, falling back to Finnhub.");
            appendDebugLog("Alpaca credentials not available, falling back to Finnhub.");
            const finnhubKey = await new Promise((resolve, reject) => {
                const request = store.get("finnhubApiKey");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (!finnhubKey) {
                console.error("Finnhub API Key is not set. Please configure it in the settings.");
                appendDebugLog("Finnhub API Key is not set. Please configure it in the settings.");
                return {};
            }

            return await fetchPricesFromFinnhub(tickers, finnhubKey);
        }

        // Fetch Prices from Alpaca
        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                const db = await openDatabase();
                const transaction = db.transaction(positionsStoreName, "readwrite");
                const store = transaction.objectStore(positionsStoreName);

                // Use Promise.all to wait for all position updates to complete
                await Promise.all(Object.entries(data).map(async ([symbol, snapshot]) => {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t ? new Date(snapshot.latestTrade.t).toLocaleString() : "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };

                    // Update the position in the Positions store
                    try {
                        const existingPosition = await new Promise((resolve, reject) => {
                            const getRequest = store.get(symbol);
                            getRequest.onsuccess = () => resolve(getRequest.result);
                            getRequest.onerror = (event) => reject(event.target.error);
                        });

                        if (existingPosition) {
                            existingPosition.lastPrice = prices[symbol].price;
                            existingPosition.lastTime = prices[symbol].time;
                            existingPosition.openPrice = prices[symbol].open;
                            existingPosition.prevClosePrice = prices[symbol].prevClose;

                            await new Promise((resolve, reject) => {
                                const putRequest = store.put(existingPosition);
                                putRequest.onsuccess = () => resolve();
                                putRequest.onerror = (event) => reject(event.target.error);
                            });

                            appendDebugLog(`Updated position for ${symbol} in IndexedDB.`);
                        }
                    } catch (error) {
                        console.error(`Error updating position for ${symbol}:`, error);
                        appendDebugLog(`Error updating position for ${symbol}: ${error}`);
                    }
                }));

                console.log("Fetched prices from Alpaca:", prices);
                appendDebugLog("Fetched prices from Alpaca.");
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                appendDebugLog(`Error fetching snapshots from Alpaca: ${error}`);
                return {};
            }
        }

        // Fetch Prices from Finnhub
        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            appendDebugLog(`Failed to fetch quote data for ${ticker} from Finnhub: ${quoteResponse.statusText}`);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                            appendDebugLog(`Failed to fetch previous close data for ${ticker} from Finnhub: ${prevCloseResponse.statusText}`);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                appendDebugLog("Fetched prices from Finnhub.");
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                appendDebugLog(`Error fetching prices from Finnhub: ${error}`);
                return {};
            }
        }

        // Function to Handle Settings Toggle
        document.getElementById("settingsIcon").addEventListener("click", () => {
            const settingsDiv = document.getElementById("settings");
            settingsDiv.classList.toggle("d-none");
        });

        // Function to Save API Keys and Refresh Interval
        document.getElementById("saveKeys").addEventListener("click", async () => {
            const alpacaApiKey = document.getElementById("alpacaApiKey").value.trim();
            const alpacaApiSecret = document.getElementById("alpacaApiSecret").value.trim();
            const finnhubApiKey = document.getElementById("finnhubApiKey").value.trim();

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readwrite");
            const store = transaction.objectStore(settingsStoreName);

            if (alpacaApiKey) {
                store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
                appendDebugLog("Alpaca API Key saved.");
            }

            if (alpacaApiSecret) {
                store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
                appendDebugLog("Alpaca API Secret saved.");
            }

            if (finnhubApiKey) {
                store.put({ key: "finnhubApiKey", value: finnhubApiKey });
                appendDebugLog("Finnhub API Key saved.");
            }

            document.getElementById("settingsFeedback").textContent = "Settings saved successfully!";
            document.getElementById("settingsFeedback").style.display = "block";
            setTimeout(() => {
                document.getElementById("settingsFeedback").style.display = "none";
            }, 3000);
        });

        // Function to Handle Reset Settings to Default
        document.getElementById("resetSettings").addEventListener("click", async () => {
            if (confirm("Are you sure you want to reset all settings to default?")) {
                try {
                    const db = await openDatabase();
                    const transaction = db.transaction(settingsStoreName, "readwrite");
                    const store = transaction.objectStore(settingsStoreName);

                    // Clear all settings
                    const clearRequest = store.clear();
                    clearRequest.onsuccess = () => {
                        appendDebugLog("Settings have been reset to default.");
                        alert("Settings have been reset to default.");
                        window.location.reload();
                    };
                    clearRequest.onerror = (event) => {
                        appendDebugLog(`Failed to reset settings: ${event.target.error}`);
                        alert("Failed to reset settings.");
                    };
                } catch (error) {
                    appendDebugLog(`Error resetting settings: ${error}`);
                    alert("An error occurred while resetting settings.");
                }
            }
        });

        // Function to Handle Reset Database Button
        document.getElementById("resetDatabase").addEventListener("click", () => {
            if (confirm("Are you sure you want to reset the database? This will delete all your data.")) {
                deleteDatabase();
            }
        });

        // Function to Delete IndexedDB Database
        async function deleteDatabase() {
            try {
                const deleteRequest = indexedDB.deleteDatabase(dbName);
                
                deleteRequest.onsuccess = () => {
                    appendDebugLog("Database deleted successfully.");
                    alert("Database has been reset successfully.");
                    // Reload the page to reinitialize the database
                    window.location.reload();
                };
                
                deleteRequest.onerror = (event) => {
                    appendDebugLog(`Error deleting database: ${event.target.error}`);
                    alert("Failed to delete the database. Please try again.");
                };
                
                deleteRequest.onblocked = () => {
                    appendDebugLog("Database deletion blocked. Please close all other tabs with this site open.");
                    alert("Database deletion is blocked. Please close all other tabs with this site open and try again.");
                };
            } catch (error) {
                appendDebugLog(`Unexpected error deleting database: ${error}`);
                alert("An unexpected error occurred while deleting the database.");
            }
        }

        // Function to Get Query Parameters
        function getQueryParam(param) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(param);
        }

        // Function to Load Position Based on Query Parameter
        async function loadPositionFromQuery() {
            const symbol = getQueryParam("symbol")?.toUpperCase();
            if (!symbol) {
                appendDebugLog("No symbol provided in query parameters.");
                return;
            }

            appendDebugLog(`Loading position for symbol: ${symbol}`);
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const request = store.get(symbol);

            request.onsuccess = (event) => {
                const position = event.target.result;
                if (position) {
                    appendDebugLog(`Position found for ${symbol}: ${JSON.stringify(position)}`);
                    document.getElementById("tickerSymbol").value = position.tickerSymbol;
                    document.getElementById("averagePrice").value = position.avgPrice;
                    document.getElementById("numShares").value = position.numShares;
                    document.getElementById("priceStep").value = position.priceStep;
                    document.getElementById("levels").value = position.levels;

                    calculateResults();
                } else {
                    appendDebugLog(`No saved position found for symbol: ${symbol}`);
                    alert(`No saved position found for symbol: ${symbol}`);
                }
            };

            request.onerror = (event) => {
                appendDebugLog(`Error loading position for symbol ${symbol}: ${event.target.error}`);
            };
        }

        // Function to Save Position
        async function savePosition() {
            const tickerSymbol = document.getElementById("tickerSymbol").value.trim().toUpperCase();
            const avgPrice = parseFloat(document.getElementById("averagePrice").value);
            const numShares = parseInt(document.getElementById("numShares").value);
            const priceStep = parseFloat(document.getElementById("priceStep").value) || avgPrice * 0.01;
            const levels = parseInt(document.getElementById("levels").value) || 5;

            if (!tickerSymbol || isNaN(avgPrice) || isNaN(numShares)) {
                alert("Please fill in all required fields to save the position.");
                appendDebugLog("Failed to save position: Missing or invalid fields.");
                return;
            }

            const position = { id: tickerSymbol, tickerSymbol, avgPrice, numShares, priceStep, levels };

            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const request = store.put(position);

            request.onsuccess = () => {
                appendDebugLog(`Position saved: ${JSON.stringify(position)}`);
                alert(`Position for ${tickerSymbol} saved successfully.`);
                loadSavedPositions();
            };

            request.onerror = (event) => {
                appendDebugLog(`Failed to save position for ${tickerSymbol}: ${event.target.error}`);
                alert("Failed to save the position. Please try again.");
            };
        }

        // Function to Load Saved Positions
        async function loadSavedPositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const request = store.getAll();

            const container = document.getElementById("savedPositionsContainer");
            container.innerHTML = ""; // Clear existing tabs

            request.onsuccess = () => {
                request.result.forEach((position) => {
                    const tab = document.createElement("div");
                    tab.className = "tab";

                    const label = document.createElement("span");
                    label.textContent = position.tickerSymbol;

                    const deleteButton = document.createElement("button");
                    deleteButton.textContent = "X";
                    deleteButton.className = "btn-delete";
                    deleteButton.addEventListener("click", async (event) => {
                        event.stopPropagation();
                        await deletePosition(position.id);
                        alert(`Position ${position.tickerSymbol} deleted successfully.`);
                        loadSavedPositions();
                    });

                    tab.appendChild(label);
                    tab.appendChild(deleteButton);

                    tab.addEventListener("click", () => {
                        document.getElementById("tickerSymbol").value = position.tickerSymbol;
                        document.getElementById("averagePrice").value = position.avgPrice;
                        document.getElementById("numShares").value = position.numShares;
                        document.getElementById("priceStep").value = position.priceStep;
                        document.getElementById("levels").value = position.levels;
                        calculateResults();
                    });

                    container.appendChild(tab);
                });
            };

            request.onerror = (event) => {
                console.error("Failed to load saved positions:", event.target.error);
            };
        }

        // Function to Delete a Position
        async function deletePosition(id) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const request = store.delete(id);

            return new Promise((resolve, reject) => {
                request.onsuccess = () => resolve();
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Calculate Results
        async function calculateResults() {
            const tickerSymbol = document.getElementById("tickerSymbol").value.trim().toUpperCase();
            const avgPrice = parseFloat(document.getElementById("averagePrice").value);
            const numShares = parseInt(document.getElementById("numShares").value);
            const priceStep = parseFloat(document.getElementById("priceStep").value) || avgPrice * 0.01;
            const levels = parseInt(document.getElementById("levels").value) || 5;

            if (!tickerSymbol || isNaN(avgPrice) || isNaN(numShares)) {
                alert("Please fill in all required fields to calculate.");
                return;
            }

            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const position = await new Promise((resolve, reject) => {
                const request = store.get(tickerSymbol);
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });

            const lastPrice = position?.lastPrice || avgPrice; // Use lastPrice if available, fallback to avgPrice

            const resultsDiv = document.getElementById("results");
            let html = '<table class="table table-dark table-bordered"><thead><tr><th>Price Level</th><th>Profit/Loss</th><th>% Gain/Loss</th></tr></thead><tbody>';

            let closestRowHtml = "";
            let smallestDifference = Infinity;
            let closestRowElement = null;

            for (let i = -levels; i <= levels; i++) {
                const priceLevel = avgPrice + i * priceStep;
                if (priceLevel < 0) continue;
                const profitLoss = (priceLevel - avgPrice) * numShares;
                const percentChange = ((priceLevel - avgPrice) / avgPrice) * 100;

                const rowHtml = `
                    <tr data-price-level="${priceLevel}">
                        <td>${priceLevel.toFixed(2)}</td>
                        <td>${profitLoss.toFixed(2)}</td>
                        <td>${percentChange.toFixed(2)}%</td>
                    </tr>
                `;

                const difference = Math.abs(priceLevel - lastPrice);
                if (difference < smallestDifference) {
                    smallestDifference = difference;
                    closestRowHtml = rowHtml;
                }

                html += rowHtml;
            }

            html += '</tbody></table>';
            resultsDiv.innerHTML = html;

            // Highlight the closest row
            const table = resultsDiv.querySelector("table");
            const rows = table.querySelectorAll("tr[data-price-level]");
            rows.forEach((row) => {
                const priceLevel = parseFloat(row.getAttribute("data-price-level"));
                const regex = /data-price-level="([\d.-]+)"/;
                const match = closestRowHtml.match(regex);
                if (match && priceLevel === parseFloat(match[1])) {
                    row.classList.add("highlight-row");
                    closestRowElement = row;
                }
            });

            // Scroll to the highlighted row
            if (closestRowElement) {
                closestRowElement.scrollIntoView({ behavior: "smooth", block: "center" });
            }
        }

        // Function to Get Sort Type Based on Column Key
        function getSortType(columnKey) {
            const stringColumns = ["tickerSymbol", "lastTime"];
            if (stringColumns.includes(columnKey)) {
                return "string";
            }
            return "number";
        }

        // Function to Get Display Name for Column
        function getColumnDisplayName(columnKey) {
            const mapping = {
                "tickerSymbol": "Ticker",
                "avgPrice": "Average Price",
                "numShares": "Shares",
                "lastPrice": "Current Price",
                "costBasis": "Cost Basis",
                "totalValue": "Total Value",
                "profit": "Profit",
                "profitPct": "Profit %",
                "changeToday": "Change Today",
                "changePctToday": "Change % Today",
                "gapPct": "Gap %",
                "lastTime": "Time Since Last Trade"
            };
            return mapping[columnKey] || columnKey;
        }

        // Function to Sort Positions
        function sortPositions() {
            if (!sortColumn) return;
            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                if (getSortType(sortColumn) === "string") {
                    valA = valA.toUpperCase();
                    valB = valB.toUpperCase();
                    if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                    if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                } else {
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
            });
        }

        // Function to Calculate Time Since Last Trade
        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        // Function to Fetch Visible Positions from IndexedDB
        async function fetchVisiblePositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => {
                    const all = event.target.result;
                    // Filter out positions where hide is true
                    const visible = all.filter(position => !position.hide);
                    resolve(visible);
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch All Unique Tickers from IndexedDB
        async function fetchAllTickers() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index.openCursor(null, "nextunique");
                const tickers = [];
                request.onsuccess = (event) => {
                    const cursor = event.target.result;
                    if (cursor) {
                        tickers.push(cursor.key);
                        cursor.continue();
                    } else {
                        resolve(tickers);
                    }
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Generate Filter Checkboxes
        async function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

            const db = await openDatabase();
            const store = db.transaction(positionsStoreName, "readonly").objectStore(positionsStoreName);

            for (const ticker of uniqueTickers) {
                const checkbox = document.createElement("div");
                checkbox.className = "form-check form-check-inline filter-checkbox";
                checkbox.innerHTML = `
                    <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" checked>
                    <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
                `;

                // Determine the initial checked state based on positions' hide attribute
                const request = store.index && store.index("tickerSymbol") ? store.index("tickerSymbol").getAll(ticker) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === ticker);
                    const isHidden = positions.every(pos => pos.hide);
                    if (isHidden) {
                        checkbox.querySelector('input').checked = false;
                    } else {
                        checkbox.querySelector('input').checked = true;
                    }
                };
                request.onerror = (event) => {
                    console.error(`Error fetching positions for ${ticker}:`, event.target.error);
                };

                // Add Event Listener for Checkbox Change
                checkbox.querySelector('input').addEventListener("change", async () => {
                    const ticker = checkbox.querySelector("input").value;
                    const isChecked = checkbox.querySelector("input").checked;
                    const hide = !isChecked;

                    // Update the 'hide' attribute for all positions with this tickerSymbol
                    try {
                        await setHideForTickerSymbol(ticker, hide);
                        console.log(`Set hide=${hide} for tickerSymbol=${ticker}`);
                        appendDebugLog(`Set hide=${hide} for tickerSymbol=${ticker}`);

                        // Reload portfolio after updating hide status
                        await loadPortfolio();
                    } catch (error) {
                        console.error(`Error setting hide for tickerSymbol=${ticker}:`, error);
                        appendDebugLog(`Error setting hide for tickerSymbol=${ticker}: ${error}`);
                    }
                });

                filterCheckboxes.appendChild(checkbox);
            }
        }

        // Function to Update the 'hide' Attribute for All Positions with a Specific Ticker Symbol
        async function setHideForTickerSymbol(tickerSymbol, hide) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);
            const index = store.index("tickerSymbol");

            return new Promise((resolve, reject) => {
                const request = index ? index.getAll(tickerSymbol) : store.getAll();
                request.onsuccess = async (event) => {
                    const positions = event.target.result.filter(pos => pos.tickerSymbol === tickerSymbol);
                    for (const position of positions) {
                        position.hide = hide;
                        const updateRequest = store.put(position);
                        await new Promise((res, rej) => {
                            updateRequest.onsuccess = () => res();
                            updateRequest.onerror = (e) => rej(e.target.error);
                        });
                    }
                    resolve();
                };
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Fetch Current Prices
        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            const alpacaKey = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_KEY_ID");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            const alpacaSecret = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_SECRET_KEY");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (alpacaKey && alpacaSecret) {
                return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
            }

            console.warn("Alpaca credentials not available, falling back to Finnhub.");
            appendDebugLog("Alpaca credentials not available, falling back to Finnhub.");
            const finnhubKey = await new Promise((resolve, reject) => {
                const request = store.get("finnhubApiKey");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (!finnhubKey) {
                console.error("Finnhub API Key is not set. Please configure it in the settings.");
                appendDebugLog("Finnhub API Key is not set. Please configure it in the settings.");
                return {};
            }

            return await fetchPricesFromFinnhub(tickers, finnhubKey);
        }

        // Fetch Prices from Alpaca
        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                for (const [symbol, snapshot] of Object.entries(data)) {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t ? new Date(snapshot.latestTrade.t).toLocaleString() : "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };
                }

                console.log("Fetched prices from Alpaca:", prices);
                appendDebugLog("Fetched prices from Alpaca.");
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                appendDebugLog(`Error fetching snapshots from Alpaca: ${error}`);
                return {};
            }
        }

        // Fetch Prices from Finnhub
        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            appendDebugLog(`Failed to fetch quote data for ${ticker} from Finnhub: ${quoteResponse.statusText}`);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                            appendDebugLog(`Failed to fetch previous close data for ${ticker} from Finnhub: ${prevCloseResponse.statusText}`);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                appendDebugLog("Fetched prices from Finnhub.");
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                appendDebugLog(`Error fetching prices from Finnhub: ${error}`);
                return {};
            }
        }

        // Function to Handle Reset Settings to Default
        document.getElementById("resetSettings").addEventListener("click", async () => {
            if (confirm("Are you sure you want to reset all settings to default?")) {
                try {
                    const db = await openDatabase();
                    const transaction = db.transaction(settingsStoreName, "readwrite");
                    const store = transaction.objectStore(settingsStoreName);

                    // Clear all settings
                    const clearRequest = store.clear();
                    clearRequest.onsuccess = () => {
                        appendDebugLog("Settings have been reset to default.");
                        alert("Settings have been reset to default.");
                        window.location.reload();
                    };
                    clearRequest.onerror = (event) => {
                        appendDebugLog(`Failed to reset settings: ${event.target.error}`);
                        alert("Failed to reset settings.");
                    };
                } catch (error) {
                    appendDebugLog(`Error resetting settings: ${error}`);
                    alert("An error occurred while resetting settings.");
                }
            }
        });

        // Function to Initialize Auto-Refresh Interval Buttons
        async function initializeRefreshIntervalButtons() {
            const buttons = document.querySelectorAll('.refresh-interval-button');
            const db = await openDatabase();
            const store = db.transaction(settingsStoreName, "readwrite").objectStore(settingsStoreName);
            const currentInterval = await new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });

            buttons.forEach(button => {
                if (parseInt(button.getAttribute('data-interval')) === currentInterval) {
                    button.classList.add('active');
                }

                button.addEventListener('click', async () => {
                    try {
                        const interval = parseInt(button.getAttribute('data-interval'));
                        
                        // Open a new transaction for each put operation
                        const newTransaction = db.transaction(settingsStoreName, "readwrite");
                        const newStore = newTransaction.objectStore(settingsStoreName);
                        
                        // Await the completion of store.put within the new transaction
                        await new Promise((resolve, reject) => {
                            const request = newStore.put({ key: "refreshInterval", value: interval });
                            request.onsuccess = () => resolve();
                            request.onerror = (event) => reject(event.target.error);
                        });

                        appendDebugLog(`Auto-refresh interval set to ${interval} seconds.`);

                        // Update button styles
                        buttons.forEach(btn => btn.classList.remove('active'));
                        button.classList.add('active');

                        // Restart auto-refresh with the new interval
                        await startAutoRefresh();

                        // Provide user feedback
                        document.getElementById("settingsFeedback").textContent = interval === 0 ? "Auto-refresh stopped." : `Auto-refresh interval set to ${interval} seconds.`;
                        document.getElementById("settingsFeedback").style.display = "block";
                        setTimeout(() => {
                            document.getElementById("settingsFeedback").style.display = "none";
                        }, 3000);
                    } catch (error) {
                        console.error("Error setting refresh interval:", error);
                        appendDebugLog(`Error setting refresh interval: ${error}`);
                        document.getElementById("settingsFeedback").textContent = "Failed to set refresh interval.";
                        document.getElementById("settingsFeedback").style.display = "block";
                        setTimeout(() => {
                            document.getElementById("settingsFeedback").style.display = "none";
                        }, 3000);
                    }
                });
            });

            console.log("Refresh interval buttons initialized.");
            appendDebugLog("Refresh interval buttons initialized.");
        }

        // Function to Initialize Visible Columns on Page Load
        async function initializeVisibleColumns() {
            const db = await openDatabase();
            const store = db.transaction(settingsStoreName, "readonly").objectStore(settingsStoreName);
            const savedColumns = await new Promise((resolve, reject) => {
                const request = store.get("visibleColumns");
                request.onsuccess = (event) => resolve(event.target.result?.value || []);
                request.onerror = (event) => reject(event.target.error);
            });

            if (savedColumns.length > 0) {
                visibleColumns = savedColumns;
                // Ensure uniqueness
                visibleColumns = [...new Set(visibleColumns)];

                console.log("Loaded visibleColumns from settings:", visibleColumns);
                appendDebugLog("Loaded visibleColumns from settings.");
            }
        }

        // Function to Sort Positions
        function sortPositions() {
            if (!sortColumn) return;
            allPositions.sort((a, b) => {
                let valA = a[sortColumn];
                let valB = b[sortColumn];

                if (getSortType(sortColumn) === "string") {
                    valA = valA.toUpperCase();
                    valB = valB.toUpperCase();
                    if (valA < valB) return sortDirection === 'asc' ? -1 : 1;
                    if (valA > valB) return sortDirection === 'asc' ? 1 : -1;
                    return 0;
                } else {
                    return sortDirection === 'asc' ? valA - valB : valB - valA;
                }
            });
        }

        // Function to Start Auto-Refresh
        async function startAutoRefresh() {
            const interval = await getRefreshInterval();
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }

            if (interval > 0) {
                refreshIntervalId = setInterval(async () => {
                    console.log("Auto-refreshing prices...");
                    appendDebugLog("Auto-refreshing prices...");

                    // Fetch current prices for all unique tickers
                    const uniqueTickers = await fetchAllTickers();
                    await fetchCurrentPrices(uniqueTickers);

                    // Fetch and update allPositions with updated data from the database
                    allPositions = await fetchVisiblePositions();

                    await loadPortfolio();
                }, interval * 1000);
                console.log(`Auto-refresh set to every ${interval} seconds.`);
                appendDebugLog(`Auto-refresh set to every ${interval} seconds.`);
            } else {
                console.log("Auto-refresh stopped.");
                appendDebugLog("Auto-refresh stopped.");
            }
        }

        // Function to Get Refresh Interval from IndexedDB
        async function getRefreshInterval() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        // Function to Open IndexedDB Database with Version 3
        function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 3); // Updated to version 3
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(positionsStoreName)) {
                        db.createObjectStore(positionsStoreName, { keyPath: "id" });
                        appendDebugLog("Created 'Positions' object store in portfolio.html.");
                    }

                    if (!db.objectStoreNames.contains(settingsStoreName)) {
                        db.createObjectStore(settingsStoreName, { keyPath: "key" });
                        appendDebugLog("Created 'Settings' object store in portfolio.html.");
                    }

                    // Add any additional upgrade logic for version 3 here
                };

                request.onsuccess = (event) => {
                    const db = event.target.result;
                    appendDebugLog("Database opened successfully in portfolio.html.");
                    appendDebugLog(`Available stores: ${Array.from(db.objectStoreNames)}`);
                    resolve(db);
                };

                request.onerror = (event) => {
                    appendDebugLog(`Failed to open database in portfolio.html: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        // Function to load sort settings from IndexedDB
        async function loadSortSettings() {
            try {
                const db = await openDatabase();
                const transaction = db.transaction(settingsStoreName, "readonly");
                const store = transaction.objectStore(settingsStoreName);

                // Get sort column
                sortColumn = await new Promise((resolve) => {
                    const request = store.get("sortColumn");
                    request.onsuccess = (event) => resolve(event.target.result?.value || null);
                    request.onerror = () => resolve(null);
                });

                // Get sort direction
                sortDirection = await new Promise((resolve) => {
                    const request = store.get("sortDirection");
                    request.onsuccess = (event) => resolve(event.target.result?.value || 'asc');
                    request.onerror = () => resolve('asc');
                });

                appendDebugLog(`Loaded sort settings: column=${sortColumn}, direction=${sortDirection}`);
            } catch (error) {
                console.error("Error loading sort settings:", error);
                appendDebugLog(`Error loading sort settings: ${error}`);
            }
        }

        // Function to Load Saved Columns from IndexedDB and Initialize UI
        async function initializeUI() {
            await initializeVisibleColumns();
            await loadSortSettings(); // Load sort settings
            populateSortableColumns();
            initializeRefreshIntervalButtons();
            await startAutoRefresh();

            // Fetch prices on initial load (optional)
            const uniqueTickers = await fetchAllTickers();
            await fetchCurrentPrices(uniqueTickers);

            await loadPortfolio();
        }

        // Initialize the application
        document.addEventListener("DOMContentLoaded", async () => {
            await initializeUI();
            // Function to Handle Filter Input with Debounce
            let debounceTimeout;
            document.getElementById("filterInput").addEventListener("input", () => {
                clearTimeout(debounceTimeout);
                debounceTimeout = setTimeout(() => {
                    renderPortfolio();
                }, 300); // Adjust the debounce delay as needed
            });
        });
    </script>
</body>
</html>