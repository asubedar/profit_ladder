<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio Tracker</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css">
    <style>
        body {
            background-color: #121212;
            color: #ffffff;
            font-family: Arial, sans-serif;
        }
        h1 {
            text-align: center;
            margin-bottom: 20px;
        }
        table {
            width: 100%;
            margin-top: 20px;
            background-color: #1e1e1e;
            color: #ffffff;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: right;
            border-bottom: 1px solid #444;
        }
        th:first-child, td:first-child {
            text-align: left;
        }
        th {
            background-color: #292929;
            cursor: pointer;
            user-select: none;
            position: relative;
        }
        th.dragging {
            background-color: #3B3B3B;
        }
        th:hover {
            text-decoration: underline;
        }
        .sort-arrow {
            margin-left: 5px;
            display: none;
        }
        th.sorted-asc .sort-arrow.asc,
        th.sorted-desc .sort-arrow.desc {
            display: inline-block;
        }
        .profit-positive {
            color: #28a745;
        }
        .profit-negative {
            color: #dc3545;
        }
        .settings {
            display: none;
            margin-top: 20px;
        }
        .settings-toggle {
            cursor: pointer;
            font-size: 20px;
            text-align: right;
            margin-bottom: 10px;
        }
        .settings-toggle:hover {
            color: #00bcd4;
        }
        .totals-row {
            font-weight: bold;
            background-color: #292929;
        }
        .refresh-interval-button {
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 30px;
            font-size: 14px;
        }
        .btn-primary {
            background-color: #007bff;
            color: #fff;
            border: none;
        }
        .filter-container {
            margin-top: 20px;
            margin-bottom: 20px;
        }
        .filter-checkbox {
            margin-right: 10px;
        }
        .drag-handle {
            cursor: grab;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 20px;
            height: 100%;
            position: absolute;
            left: 0;
            top: 0;
        }
        .drag-handle i {
            font-size: 14px;
            color: #666;
        }
        .th-name {
            margin-left: 20px;
        }
        .column-checkbox {
            margin-right: 10px;
        }
        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .table-responsive {
                display: block;
                width: 100%;
                overflow-x: auto;
            }
            .table-responsive table {
                width: auto;
                min-width: 100%;
            }
            th, td {
                white-space: nowrap;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
        <div class="container-fluid">
            <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
            <div class="collapse navbar-collapse">
                <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                    <li class="nav-item">
                        <a class="nav-link" href="./">Profit Ladder</a>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link active" aria-current="page" href="./portfolio.html">Portfolio</a>
                    </li>
                </ul>
            </div>
        </div>
    </nav>
    <div class="container">
        <div class="filter-container">
            <input type="text" id="filterInput" class="form-control" placeholder="Filter by ticker...">
            <div id="filterCheckboxes" class="mt-2"></div>
        </div>
        <div class="table-responsive">
            <table id="portfolioTable">
                <thead>
                    <tr>
                        <th data-column="tickerSymbol" data-sort-type="string" data-sort-key="tickerSymbol" data-col-index="0"><span class="th-name">Ticker</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="avgPrice" data-sort-type="number" data-sort-key="avgPrice" data-col-index="1"><span class="th-name">Average Price</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="numShares" data-sort-type="number" data-sort-key="numShares" data-col-index="2"><span class="th-name">Shares</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="lastPrice" data-sort-type="number" data-sort-key="lastPrice" data-col-index="3"><span class="th-name">Current Price</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="costBasis" data-sort-type="number" data-sort-key="costBasis" data-col-index="4"><span class="th-name">Cost Basis</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="totalValue" data-sort-type="number" data-sort-key="totalValue" data-col-index="5"><span class="th-name">Total Value</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="profit" data-sort-type="number" data-sort-key="profit" data-col-index="6"><span class="th-name">Profit</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="profitPct" data-sort-type="number" data-sort-key="profitPct" data-col-index="7"><span class="th-name">Profit %</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="changeToday" data-sort-type="number" data-sort-key="changeToday" data-col-index="8"><span class="th-name">Change Today</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="changePctToday" data-sort-type="number" data-sort-key="changePctToday" data-col-index="9"><span class="th-name">Change % Today</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="gapPct" data-sort-type="number" data-sort-key="gapPct" data-col-index="10"><span class="th-name">Gap %</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                        <th data-column="lastTime" data-sort-type="string" data-sort-key="lastTime" data-col-index="11"><span class="th-name">Time Since Last Trade</span><span class="sort-arrow asc">▲</span><span class="sort-arrow desc">▼</span></th>
                    </tr>
                </thead>
                <tbody id="portfolioBody"></tbody>
                <tfoot>
                    <tr class="totals-row">
                        <td>Totals</td>
                        <td colspan="3"></td>
                        <td id="totalCostBasis">0.00</td>
                        <td id="totalValue">0.00</td>
                        <td id="totalProfit">0.00</td>
                        <td id="totalProfitPct">0.00</td>
                        <td id="totalChangeToday">0.00</td>
                        <td id="totalChangePctToday">0.00</td>
                        <td id="totalGapPct">0.00</td>
                        <td></td>
                    </tr>
                </tfoot>
            </table>
        </div>
        <h3 class="mt-4">Auto-Refresh Interval</h3>
        <div id="refreshIntervalButtons" class="d-flex gap-2 mt-2">
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="0">Stop</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="5">5s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="10">10s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="30">30s</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="60">1m</button>
            <button class="btn btn-outline-light btn-sm refresh-interval-button" data-interval="300">5m</button>
        </div>
        <div id="settingsFeedback" class="mt-2 text-success" style="display: none;"></div>
        <div class="settings-toggle text-right">
            <span id="settingsIcon">⚙️ Settings</span>
        </div>
        <div class="settings" id="settings">
            <h3>Settings</h3>
            <div id="columnCustomization" class="mb-3">
                <h4>Customize Columns</h4>
                <ul id="sortableColumns" style="list-style-type: none; padding: 0;">
                    <li class="column-item" data-column="tickerSymbol">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-tickerSymbol" value="tickerSymbol" checked>
                        <label class="form-check-label text-light" for="checkbox-tickerSymbol">Ticker</label>
                    </li>
                    <li class="column-item" data-column="avgPrice">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-avgPrice" value="avgPrice" checked>
                        <label class="form-check-label text-light" for="checkbox-avgPrice">Average Price</label>
                    </li>
                    <li class="column-item" data-column="numShares">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-numShares" value="numShares" checked>
                        <label class="form-check-label text-light" for="checkbox-numShares">Shares</label>
                    </li>
                    <li class="column-item" data-column="lastPrice">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-lastPrice" value="lastPrice" checked>
                        <label class="form-check-label text-light" for="checkbox-lastPrice">Current Price</label>
                    </li>
                    <li class="column-item" data-column="costBasis">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-costBasis" value="costBasis" checked>
                        <label class="form-check-label text-light" for="checkbox-costBasis">Cost Basis</label>
                    </li>
                    <li class="column-item" data-column="totalValue">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-totalValue" value="totalValue" checked>
                        <label class="form-check-label text-light" for="checkbox-totalValue">Total Value</label>
                    </li>
                    <li class="column-item" data-column="profit">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-profit" value="profit" checked>
                        <label class="form-check-label text-light" for="checkbox-profit">Profit</label>
                    </li>
                    <li class="column-item" data-column="profitPct">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-profitPct" value="profitPct" checked>
                        <label class="form-check-label text-light" for="checkbox-profitPct">Profit %</label>
                    </li>
                    <li class="column-item" data-column="changeToday">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-changeToday" value="changeToday" checked>
                        <label class="form-check-label text-light" for="checkbox-changeToday">Change Today</label>
                    </li>
                    <li class="column-item" data-column="changePctToday">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-changePctToday" value="changePctToday" checked>
                        <label class="form-check-label text-light" for="checkbox-changePctToday">Change % Today</label>
                    </li>
                    <li class="column-item" data-column="gapPct">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-gapPct" value="gapPct" checked>
                        <label class="form-check-label text-light" for="checkbox-gapPct">Gap %</label>
                    </li>
                    <li class="column-item" data-column="lastTime">
                        <input class="form-check-input column-checkbox" type="checkbox" id="checkbox-lastTime" value="lastTime" checked>
                        <label class="form-check-label text-light" for="checkbox-lastTime">Time Since Last Trade</label>
                    </li>
                </ul>
            </div>
            <label for="alpacaApiKey">Alpaca API Key:</label>
            <input type="text" id="alpacaApiKey" class="form-control" placeholder="Enter your Alpaca API Key">
            <label for="alpacaApiSecret" class="mt-2">Alpaca API Secret:</label>
            <input type="text" id="alpacaApiSecret" class="form-control" placeholder="Enter your Alpaca API Secret">
            <label for="apiKeyInput" class="mt-2">Finnhub API Key:</label>
            <input type="text" id="apiKeyInput" class="form-control" placeholder="Enter your Finnhub API Key">
            <button id="saveKeys" class="btn btn-primary mt-2">Save Settings</button>
        </div>
    </div>

    <script>
        const dbName = "ProfitLadderDB";
        const positionsStoreName = "Positions";
        const settingsStoreName = "Settings";

        let refreshIntervalId;
        let sortColumn = null;
        let sortDirection = 'asc';
        let allPositions = [];
        let selectedTickers = [];
        let visibleColumns = [
            "tickerSymbol",
            "avgPrice",
            "numShares",
            "lastPrice",
            "costBasis",
            "totalValue",
            "profit",
            "profitPct",
            "changeToday",
            "changePctToday",
            "gapPct",
            "lastTime"
        ];

        async function fetchCurrentPrices(tickers) {
            if (!tickers || tickers.length === 0) {
                return {};
            }

            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            const alpacaKey = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_KEY_ID");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            const alpacaSecret = await new Promise((resolve, reject) => {
                const request = store.get("APCA_API_SECRET_KEY");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (alpacaKey && alpacaSecret) {
                return await fetchPricesFromAlpaca(tickers, alpacaKey, alpacaSecret);
            }

            console.warn("Alpaca credentials not available, falling back to Finnhub.");
            const finnhubKey = await new Promise((resolve, reject) => {
                const request = store.get("finnhubApiKey");
                request.onsuccess = (event) => resolve(event.target.result?.value || "");
                request.onerror = (event) => reject(event.target.error);
            });

            if (!finnhubKey) {
                console.error("Finnhub API Key is not set. Please configure it in the settings.");
                return {};
            }

            return await fetchPricesFromFinnhub(tickers, finnhubKey);
        }

        async function fetchPricesFromAlpaca(tickers, apiKey, apiSecret) {
            const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${tickers.join(",")}`;
            try {
                const response = await fetch(url, {
                    headers: {
                        "APCA-API-KEY-ID": apiKey,
                        "APCA-API-SECRET-KEY": apiSecret,
                    },
                });

                if (!response.ok) {
                    console.error("Failed to fetch snapshots from Alpaca:", response.statusText);
                    return {};
                }

                const data = await response.json();
                const prices = {};

                for (const [symbol, snapshot] of Object.entries(data)) {
                    prices[symbol] = {
                        price: snapshot.latestTrade?.p || 0,
                        time: snapshot.latestTrade?.t || "N/A",
                        open: snapshot.dailyBar?.o || 0,
                        prevClose: snapshot.prevDailyBar?.c || 0,
                    };
                }

                console.log("Fetched prices from Alpaca:", prices);
                return prices;
            } catch (error) {
                console.error("Error fetching snapshots from Alpaca:", error);
                return {};
            }
        }

        async function fetchPricesFromFinnhub(tickers, apiKey) {
            try {
                const responses = await Promise.all(
                    tickers.map(async (ticker) => {
                        const [quoteResponse, prevCloseResponse] = await Promise.all([
                            fetch(`https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${apiKey}`),
                            fetch(`https://finnhub.io/api/v1/stock/candle?symbol=${ticker}&resolution=D&count=2&token=${apiKey}`)
                        ]);

                        if (!quoteResponse.ok) {
                            console.error(`Failed to fetch quote data for ${ticker} from Finnhub:`, quoteResponse.statusText);
                            return { ticker, price: 0, time: "N/A", open: 0, prevClose: 0 };
                        }
                        const quoteData = await quoteResponse.json();

                        let prevClose = 0;
                        if (!prevCloseResponse.ok) {
                            console.warn(`Failed to fetch previous close data for ${ticker} from Finnhub:`, prevCloseResponse.statusText);
                        } else {
                            const prevCloseData = await prevCloseResponse.json();
                            prevClose = prevCloseData.c && prevCloseData.c.length > 1 ? prevCloseData.c[prevCloseData.c.length - 2] : 0;
                        }

                        return { ticker, price: quoteData.c || 0, time: new Date().toLocaleString(), open: quoteData.o || 0, prevClose: prevClose };
                    })
                );

                const prices = {};
                responses.forEach((res) => {
                    if (res.ticker) {
                        prices[res.ticker] = { price: res.price, time: res.time, open: res.open, prevClose: res.prevClose };
                    }
                });
                console.log("Fetched prices from Finnhub:", prices);
                return prices;
            } catch (error) {
                console.error("Error fetching prices from Finnhub:", error);
                return {};
            }
        }

        async function loadPortfolio() {
            allPositions = await fetchPositions();
            const uniqueTickers = [...new Set(allPositions.map((p) => p.tickerSymbol))];
            selectedTickers = selectedTickers.length === 0 ? uniqueTickers : selectedTickers;
            generateFilterCheckboxes(uniqueTickers);
            renderPortfolio();
        }

        function renderPortfolio() {
            const filteredPositions = filterPositions(allPositions, selectedTickers);
            const portfolioBody = document.getElementById("portfolioBody");
            portfolioBody.innerHTML = "";

            let totalCostBasis = 0;
            let totalValue = 0;
            let totalProfit = 0;
            let totalProfitPct = 0;
            let totalChangeToday = 0;
            let totalChangePctToday = 0;
            let totalGapPct = 0;

            const pricedPositions = filteredPositions.map(async (position) => {
                const priceData = await fetchCurrentPrices([position.tickerSymbol]);
                const currentPrice = priceData[position.tickerSymbol]?.price || position.lastPrice || 0;
                const lastTime = priceData[position.tickerSymbol]?.time || position.lastTime || "N/A";
                const openPrice = priceData[position.tickerSymbol]?.open || 0;
                const prevClosePrice = priceData[position.tickerSymbol]?.prevClose || 0;

                if (currentPrice > 0) {
                    await updatePosition(position.tickerSymbol, currentPrice, lastTime, openPrice, prevClosePrice);
                    position.lastPrice = currentPrice;
                    position.lastTime = lastTime;
                    position.openPrice = openPrice;
                    position.prevClosePrice = prevClosePrice;
                }

                const costBasis = position.avgPrice * position.numShares;
                const totalValueForPosition = currentPrice * position.numShares;
                const profit = totalValueForPosition - costBasis;
                const profitPct = costBasis !== 0 ? (profit / costBasis) * 100 : 0;
                const changeToday = currentPrice - position.openPrice;
                const changePctToday = position.openPrice !== 0 ? ((currentPrice - position.openPrice) / position.openPrice) * 100 : 0;
                const gapPct = position.prevClosePrice !== 0 ? ((position.openPrice - position.prevClosePrice) / position.prevClosePrice) * 100 : 0;

                totalCostBasis += costBasis;
                totalValue += totalValueForPosition;
                totalProfit += profit;

                return { ...position, costBasis, totalValue: totalValueForPosition, profit, profitPct, changeToday, changePctToday, gapPct };
            });

            Promise.all(pricedPositions).then((positionsWithValues) => {
                totalProfitPct = totalCostBasis !== 0 ? (totalProfit / totalCostBasis) * 100 : 0;
                totalChangeToday = positionsWithValues.reduce((sum, pos) => sum + pos.changeToday, 0);
                totalChangePctToday = positionsWithValues.length > 0 ? positionsWithValues.reduce((sum, pos) => sum + pos.changePctToday, 0) / positionsWithValues.length : 0;
                totalGapPct = positionsWithValues.length > 0 ? positionsWithValues.reduce((sum, pos) => sum + pos.gapPct, 0) / positionsWithValues.length : 0;

                if (sortColumn !== null) {
                    positionsWithValues.sort((a, b) => {
                        const aVal = sortColumn === 'tickerSymbol' || sortColumn === 'lastTime' ? a[sortColumn] : parseFloat(a[sortColumn]);
                        const bVal = sortColumn === 'tickerSymbol' || sortColumn === 'lastTime' ? b[sortColumn] : parseFloat(b[sortColumn]);

                        if (sortDirection === 'asc') {
                            return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                        } else {
                            return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                        }
                    });
                }

                positionsWithValues.forEach((position) => {
                    const { tickerSymbol, avgPrice, numShares, lastPrice, costBasis, totalValue, profit, profitPct, changeToday, changePctToday, gapPct, lastTime } = position;
                    const profitClass = profit >= 0 ? "profit-positive" : "profit-negative";
                    const changeTodayClass = changeToday >= 0 ? "profit-positive" : "profit-negative";
                    const changePctTodayClass = changePctToday >= 0 ? "profit-positive" : "profit-negative";
                    const gapPctClass = gapPct >= 0 ? "profit-positive" : "profit-negative";
                    const timeSinceLastTrade = calculateTimeSinceLastTrade(lastTime);

                    const row = `
                        <tr>
                            <td data-column="tickerSymbol" ${visibleColumns.includes('tickerSymbol') ? '' : ' style="display: none;"'}>${tickerSymbol}</td>
                            <td data-column="avgPrice" ${visibleColumns.includes('avgPrice') ? '' : ' style="display: none;"'}>${avgPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td data-column="numShares" ${visibleColumns.includes('numShares') ? '' : ' style="display: none;"'}>${numShares.toLocaleString()}</td>
                            <td data-column="lastPrice" ${visibleColumns.includes('lastPrice') ? '' : ' style="display: none;"'}>${lastPrice.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td data-column="costBasis" ${visibleColumns.includes('costBasis') ? '' : ' style="display: none;"'}>${costBasis.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td data-column="totalValue" ${visibleColumns.includes('totalValue') ? '' : ' style="display: none;"'}>${totalValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td data-column="profit" ${visibleColumns.includes('profit') ? '' : ' style="display: none;"'} class="${profitClass}">${profit.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td data-column="profitPct" ${visibleColumns.includes('profitPct') ? '' : ' style="display: none;"'} class="${profitClass}">${profitPct.toFixed(2)}%</td>
                            <td data-column="changeToday" ${visibleColumns.includes('changeToday') ? '' : ' style="display: none;"'} class="${changeTodayClass}">${changeToday.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 })}</td>
                            <td data-column="changePctToday" ${visibleColumns.includes('changePctToday') ? '' : ' style="display: none;"'} class="${changePctTodayClass}">${changePctToday.toFixed(2)}%</td>
                            <td data-column="gapPct" ${visibleColumns.includes('gapPct') ? '' : ' style="display: none;"'} class="${gapPctClass}">${gapPct.toFixed(2)}%</td>
                            <td data-column="lastTime" ${visibleColumns.includes('lastTime') ? '' : ' style="display: none;"'}>${timeSinceLastTrade}</td>
                        </tr>
                    `;
                    portfolioBody.innerHTML += row;
                });

                document.getElementById("totalCostBasis").textContent = totalCostBasis.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalValue").textContent = totalValue.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalProfit").textContent = totalProfit.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalProfitPct").textContent = totalProfitPct.toFixed(2) + "%";
                document.getElementById("totalChangeToday").textContent = totalChangeToday.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
                document.getElementById("totalChangePctToday").textContent = totalChangePctToday.toFixed(2) + "%";
                document.getElementById("totalGapPct").textContent = totalGapPct.toFixed(2) + "%";
            });
        }

        function calculateTimeSinceLastTrade(lastTradeTime) {
            if (lastTradeTime === "N/A") return "N/A";
            const lastTradeDate = new Date(lastTradeTime);
            const now = new Date();
            const diffInSeconds = Math.round((now - lastTradeDate) / 1000);

            if (diffInSeconds < 60) {
                return `${diffInSeconds}s ago`;
            } else if (diffInSeconds < 3600) {
                const minutes = Math.round(diffInSeconds / 60);
                return `${minutes}m ago`;
            } else if (diffInSeconds < 86400) {
                const hours = Math.round(diffInSeconds / 3600);
                return `${hours}h ago`;
            } else {
                const days = Math.round(diffInSeconds / 86400);
                return `${days}d ago`;
            }
        }

        async function fetchPositions() {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readonly");
            const store = transaction.objectStore(positionsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        async function updatePosition(tickerSymbol, currentPrice, lastTime, openPrice, prevClosePrice) {
            const db = await openDatabase();
            const transaction = db.transaction(positionsStoreName, "readwrite");
            const store = transaction.objectStore(positionsStoreName);

            const position = await new Promise((resolve, reject) => {
                const request = store.get(tickerSymbol);
                request.onsuccess = (event) => resolve(event.target.result);
                request.onerror = (event) => reject(event.target.error);
            });

            if (position) {
                position.lastPrice = currentPrice;
                position.lastTime = lastTime;
                position.openPrice = openPrice;
                position.prevClosePrice = prevClosePrice;
                store.put(position);
            }
        }

        async function openDatabase() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(dbName, 2);
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;

                    if (!db.objectStoreNames.contains(positionsStoreName)) {
                        db.createObjectStore(positionsStoreName, { keyPath: "tickerSymbol" });
                        appendDebugLog("Created 'Positions' object store.");
                    }

                    if (!db.objectStoreNames.contains(settingsStoreName)) {
                        db.createObjectStore(settingsStoreName, { keyPath: "key" });
                        appendDebugLog("Created 'Settings' object store.");
                    }
                };

                request.onsuccess = (event) => {
                    const db = event.target.result;
                    resolve(db);
                };

                request.onerror = (event) => {
                    appendDebugLog(`Database open failed: ${event.target.error}`);
                    reject(event.target.error);
                };
            });
        }

        async function startAutoRefresh() {
            const interval = await getRefreshInterval();
            if (refreshIntervalId) {
                clearInterval(refreshIntervalId);
            }

            if (interval > 0) {
                refreshIntervalId = setInterval(async () => {
                    console.log("Auto-refreshing prices...");
                    await renderPortfolio();
                }, interval * 1000);
            }
        }

        async function getRefreshInterval() {
            const db = await openDatabase();
            const transaction = db.transaction(settingsStoreName, "readonly");
            const store = transaction.objectStore(settingsStoreName);

            return new Promise((resolve, reject) => {
                const request = store.get("refreshInterval");
                request.onsuccess = (event) => resolve(event.target.result?.value || 0);
                request.onerror = (event) => reject(event.target.error);
            });
        }

        function generateFilterCheckboxes(uniqueTickers) {
            const filterCheckboxes = document.getElementById("filterCheckboxes");
            filterCheckboxes.innerHTML = "";

uniqueTickers.forEach((ticker) => {
    const isChecked = selectedTickers.includes(ticker);
    const checkbox = document.createElement("div");
    checkbox.className = "form-check form-check-inline filter-checkbox";
    checkbox.innerHTML = `
        <input class="form-check-input" type="checkbox" id="checkbox-${ticker}" value="${ticker}" ${isChecked ? "checked" : ""}>
        <label class="form-check-label text-light" for="checkbox-${ticker}">${ticker}</label>
    `;

    checkbox.addEventListener("change", () => {
        const ticker = checkbox.querySelector("input").value;
        if (checkbox.querySelector("input").checked) {
            if (!selectedTickers.includes(ticker)) {
                selectedTickers.push(ticker);
            }
        } else {
            selectedTickers = selectedTickers.filter((t) => t !== ticker);
        }
        renderPortfolio();
    });

    filterCheckboxes.appendChild(checkbox);
});
}

function filterPositions(positions, selectedTickers) {
const filterInput = document.getElementById("filterInput");
const filterText = filterInput.value.toLowerCase();
return positions.filter((position) => {
    const tickerMatches = position.tickerSymbol.toLowerCase().includes(filterText);
    const isSelected = selectedTickers.includes(position.tickerSymbol);
    return tickerMatches && isSelected;
});
}

document.addEventListener("DOMContentLoaded", async () => {
const settingsIcon = document.getElementById("settingsIcon");
const settingsSection = document.getElementById("settings");

settingsIcon.addEventListener("click", () => {
    if (settingsSection.style.display === "none" || !settingsSection.style.display) {
        settingsSection.style.display = "block";
    } else {
        settingsSection.style.display = "none";
    }
});

const refreshButtons = document.querySelectorAll(".refresh-interval-button");

refreshButtons.forEach((button) => {
    button.addEventListener("click", async (event) => {
        const selectedInterval = parseInt(event.target.getAttribute("data-interval"));
        await saveRefreshInterval(selectedInterval);

        refreshButtons.forEach((btn) => btn.classList.remove("btn-primary"));
        event.target.classList.add("btn-primary");

        startAutoRefresh();
    });
});

const saveKeysButton = document.getElementById("saveKeys");
saveKeysButton.addEventListener("click", async () => {
    const alpacaKey = document.getElementById("alpacaApiKey").value;
    const alpacaSecret = document.getElementById("alpacaApiSecret").value;
    const finnhubKey = document.getElementById("apiKeyInput").value;

    try {
        await saveKeys(alpacaKey, alpacaSecret, finnhubKey);
        showFeedback("Settings saved successfully!", "success");
    } catch (error) {
        console.error("Failed to save settings:", error);
        showFeedback("Failed to save settings.", "danger");
    }
});

const tableHeaders = document.querySelectorAll("#portfolioTable thead th");

tableHeaders.forEach((header) => {
    header.addEventListener("click", (event) => {
       const newSortColumn = header.getAttribute("data-sort-key");
        const sortType = header.getAttribute("data-sort-type");

        if (sortColumn === newSortColumn) {
            sortDirection = sortDirection === "asc" ? "desc" : "asc";
        } else {
            sortColumn = newSortColumn;
            sortDirection = "asc";
        }

        tableHeaders.forEach((h) => {
            h.classList.remove("sorted-asc", "sorted-desc");
        });
        header.classList.add(sortDirection === "asc" ? "sorted-asc" : "sorted-desc");

        renderPortfolio();
    });
});

const filterInput = document.getElementById("filterInput");
filterInput.addEventListener("input", renderPortfolio);

await loadSavedVisibleColumns();
await loadSavedRefreshInterval();
await loadPortfolio();
await startAutoRefresh();
setupColumnCustomization();
});

async function saveKeys(alpacaKey, alpacaSecret, finnhubKey) {
const db = await openDatabase();
const transaction = db.transaction(settingsStoreName, "readwrite");
const store = transaction.objectStore(settingsStoreName);

appendDebugLog("Saving API keys...");

if (alpacaKey) {
    store.put({ key: "APCA_API_KEY_ID", value: alpacaKey });
    appendDebugLog(`Alpaca Key saved: ${alpacaKey}`);
}

if (alpacaSecret) {
    store.put({ key: "APCA_API_SECRET_KEY", value: alpacaSecret });
    appendDebugLog("Alpaca Secret saved.");
}

if (finnhubKey) {
    store.put({ key: "finnhubApiKey", value: finnhubKey });
    appendDebugLog("Finnhub Key saved.");
}

return new Promise((resolve, reject) => {
    transaction.oncomplete = () => {
        appendDebugLog("Settings saved successfully.");
        resolve();
    };

    transaction.onerror = (event) => {
        appendDebugLog(`Failed to save settings: ${event.target.error}`);
        reject(event.target.error);
    };
});
}

function showFeedback(message, type) {
const feedbackDiv = document.getElementById("settingsFeedback");
feedbackDiv.textContent = message;
feedbackDiv.className = `mt-2 text-${type}`;
feedbackDiv.style.display = "block";

setTimeout(() => {
    feedbackDiv.style.display = "none";
}, 3000);
}

async function saveRefreshInterval(interval) {
const db = await openDatabase();
const transaction = db.transaction(settingsStoreName, "readwrite");
const store = transaction.objectStore(settingsStoreName);

store.put({ key: "refreshInterval", value: interval });

return new Promise((resolve, reject) => {
    transaction.oncomplete = () => {
        console.log("Refresh interval saved successfully!");
        resolve();
    };
    transaction.onerror = (event) => {
        console.error("Failed to save refresh interval.", event.target.error);
        reject(event.target.error);
    };
});
}

async function loadSavedRefreshInterval() {
const interval = await getRefreshInterval();
const refreshButtons = document.querySelectorAll(".refresh-interval-button");

refreshButtons.forEach((button) => {
    if (parseInt(button.getAttribute("data-interval")) === interval) {
        button.classList.add("btn-primary");
    } else {
        button.classList.remove("btn-primary");
    }
});
}

function appendDebugLog(message) {
const debugDiv = document.getElementById("debugLogs");
const log = document.createElement("div");
log.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
debugDiv.appendChild(log);
}

function setupColumnCustomization() {
const sortableColumns = document.getElementById("sortableColumns");
const columnCheckboxes = document.querySelectorAll("#columnCustomization .column-checkbox");
const columnItems = document.querySelectorAll("#sortableColumns .column-item");

let draggedItem = null;

sortableColumns.addEventListener("dragstart", (event) => {
    draggedItem = event.target;
    event.dataTransfer.effectAllowed = "move";
    event.dataTransfer.setData("text/plain", "");
    setTimeout(() => {
        draggedItem.style.opacity = "0.5";
    }, 0);
});

sortableColumns.addEventListener("dragover", (event) => {
    event.preventDefault();
    const targetItem = event.target.closest(".column-item");
    if (targetItem) {
        const bounding = targetItem.getBoundingClientRect();
        const offset = bounding.y + bounding.height / 2;

        if (event.clientY - offset > 0) {
            targetItem.style.borderBottom = "2px solid white";
            targetItem.style.borderTop = "";
        } else {
            targetItem.style.borderTop = "2px solid white";
            targetItem.style.borderBottom = "";
        }
    }
});

sortableColumns.addEventListener("dragleave", (event) => {
    const targetItem = event.target.closest(".column-item");
    if (targetItem) {
        targetItem.style.borderTop = "";
        targetItem.style.borderBottom = "";
    }
});

sortableColumns.addEventListener("drop", async (event) => {
    event.preventDefault();
    const targetItem = event.target.closest(".column-item");
    if (draggedItem && targetItem) {
        if (draggedItem !== targetItem) {
            if (targetItem.style.borderBottom === "2px solid white") {
                sortableColumns.insertBefore(draggedItem, targetItem.nextSibling);
            } else {
                sortableColumns.insertBefore(draggedItem, targetItem);
            }
            await updateVisibleColumns();
            updateTableColumns();
            renderPortfolio();
        }
        targetItem.style.borderTop = "";
        targetItem.style.borderBottom = "";
        draggedItem.style.opacity = "";
        draggedItem = null;
    }
});

columnCheckboxes.forEach((checkbox) => {
    checkbox.addEventListener("change", async () => {
        const columnKey = checkbox.value;
        if (checkbox.checked) {
            if (!visibleColumns.includes(columnKey)) {
                visibleColumns.push(columnKey);
            }
        } else {
            visibleColumns = visibleColumns.filter((key) => key !== columnKey);
        }
        await saveVisibleColumns();
        updateTableColumns();
        renderPortfolio();
    });
});
}

async function saveVisibleColumns() {
const db = await openDatabase();
const transaction = db.transaction(settingsStoreName, "readwrite");
const store = transaction.objectStore(settingsStoreName);
const sortedColumnItems = document.querySelectorAll("#sortableColumns .column-item");
const updatedVisibleColumns = Array.from(sortedColumnItems).map(item => item.getAttribute("data-column")).filter(column => visibleColumns.includes(column));

store.put({ key: "visibleColumns", value: updatedVisibleColumns });

return new Promise((resolve, reject) => {
    transaction.oncomplete = () => {
        console.log("Visible columns saved successfully!");
        resolve();
    };
    transaction.onerror = (event) => {
        console.error("Failed to save visible columns.", event.target.error);
        reject(event.target.error);
    };
});
}

async function loadSavedVisibleColumns() {
const db = await openDatabase();
const transaction = db.transaction(settingsStoreName, "readonly");
const store = transaction.objectStore(settingsStoreName);

return new Promise((resolve, reject) => {
    const request = store.get("visibleColumns");
    request.onsuccess = (event) => {
        const savedVisibleColumns = event.target.result?.value;
        if (savedVisibleColumns) {
            visibleColumns = savedVisibleColumns;
            updateCheckboxes();
        }
        resolve();
    };
    request.onerror = (event) => {
        console.error("Failed to load visible columns.", event.target.error);
        reject(event.target.error);
    };
});
}

function updateCheckboxes() {
const columnCheckboxes = document.querySelectorAll("#sortableColumns .column-checkbox");
const columnItems = document.querySelectorAll("#sortableColumns .column-item");

columnCheckboxes.forEach((checkbox) => {
    checkbox.checked = visibleColumns.includes(checkbox.value);
});

const sortableColumns = document.getElementById("sortableColumns");
visibleColumns.forEach(columnKey => {
    const columnItem = Array.from(columnItems).find(item => item.getAttribute("data-column") === columnKey);
    if (columnItem) {
        sortableColumns.appendChild(columnItem);
    }
});
}

function updateTableColumns() {
const tableHeaders = document.querySelectorAll("#portfolioTable thead th");
const bodyRows = document.querySelectorAll("#portfolioTable tbody tr");
const footerRow = document.querySelector("#portfolioTable tfoot tr");
const headerMap = {};

tableHeaders.forEach(header => {
    const headerKey = header.getAttribute("data-sort-key");
    headerMap[headerKey] = header;
});

tableHeaders.forEach(header => {
    const headerKey = header.getAttribute("data-sort-key");
    header.style.display = visibleColumns.includes(headerKey) ? "" : "none";
});

bodyRows.forEach(row => {
    const cells = row.querySelectorAll("td");
    cells.forEach((cell, index) => {
        const headerKey = Object.keys(headerMap)[index];
        if (headerKey) {
            cell.style.display = visibleColumns.includes(headerKey) ? "" : "none";
        }
    });
});

footerCells.forEach((cell, index) => {
    if (index > 0 && index <= tableHeaders.length) {
        const headerKey = tableHeaders[index - 1].getAttribute("data-sort-key");
        cell.style.display = visibleColumns.includes(headerKey) ? "" : "none";
    }
});
}

async function updateVisibleColumns() {
const columnItems = document.querySelectorAll("#sortableColumns .column-item");
const newVisibleColumns = [];

columnItems.forEach((item) => {
    const checkbox = item.querySelector(".column-checkbox");
    if (checkbox.checked) {
        newVisibleColumns.push(checkbox.value);
    }
});

visibleColumns = newVisibleColumns;

await saveVisibleColumns();
updateCheckboxes();
updateTableColumns();
}
</script>
<div id="debugLogs" style="margin-top: 20px; color: #ff6f61; font-family: monospace;"></div>
</body>
</html>