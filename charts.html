<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Real-time Stock Chart</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css"
  />
  <style>
    body {
      background-color: #121212;
      color: #ffffff;
      font-family: Arial, sans-serif;
    }
    #chartContainer {
      width: 90%;
      height: 400px;
      margin: 20px auto 10px;
      background-color: #131722;
      position: relative; /* For tooltip positioning */
    }
    #volumeChartContainer {
      width: 90%;
      height: 100px;
      margin: 0 auto 20px;
      background-color: #131722;
    }
    .settings-toggle {
      cursor: pointer;
      font-size: 20px;
      text-align: right;
      margin-bottom: 10px;
      margin-top: 20px;
    }
    .settings-toggle:hover {
      color: #00bcd4;
    }
    .settings {
      margin-top: 20px;
      background-color: #1e1e1e;
      padding: 20px;
      border-radius: 5px;
    }
    .btn-primary {
      background-color: #007bff;
      color: #fff;
      border: none;
    }
    /* Debug Logs Styling */
    #debugLogs {
      background-color: #1e1e1e;
      padding: 10px;
      border: 1px solid #444;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 20px;
      font-family: monospace;
      color: #ff6f61;
    }
    /* Chart Controls Styling */
    #chartControls {
      margin-top: 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #chartControls label {
      color: #ffffff;
    }
    #chartControls input {
      background-color: #1e1e1e;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      border-radius: 4px;
    }
    .timeframe-buttons {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    .timeframe-button {
      background-color: #343a40;
      color: #fff;
      border: none;
      padding: 5px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .timeframe-button:hover {
      background-color: #555e64;
    }
    .timeframe-button.active {
      background-color: #007bff;
    }
    /* Tooltip Styling */
    .chart-tooltip {
      position: absolute;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
      <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#navbarNav"
        aria-controls="navbarNav"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="./">Profit Ladder</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./portfolio.html">Portfolio</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="./charts.html"
              >Charts</a
            >
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <div class="container">
    <!-- Chart Controls -->
    <div id="chartControls">
      <label for="tickerInput">Ticker:</label>
      <input type="text" id="tickerInput" placeholder="Enter ticker symbol" />
      <div class="timeframe-buttons">
        <label>Timeframe:</label>
        <button class="timeframe-button" data-timeframe="1Min">1m</button>
        <button class="timeframe-button active" data-timeframe="5Min">5m</button>
        <button class="timeframe-button" data-timeframe="15Min">15m</button>
        <button class="timeframe-button" data-timeframe="30Min">30m</button>
        <button class="timeframe-button" data-timeframe="1H">1H</button>
        <button class="timeframe-button" data-timeframe="4H">4H</button>
        <button class="timeframe-button" data-timeframe="1D">1D</button>
        <button class="timeframe-button" data-timeframe="1W">1W</button>
        <button class="timeframe-button" data-timeframe="1M">1M</button>
      </div>
    </div>

    <div class="settings-toggle text-end mt-4">
      <span id="settingsIcon"><i class="fas fa-cog"></i> Settings</span>
    </div>

    <!-- Settings Section -->
    <div class="settings d-none" id="settings">
      <h3>Settings</h3>
      <!-- API Keys Section -->
      <div class="mb-3">
        <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
        <input
          type="text"
          id="alpacaApiKey"
          class="form-control"
          placeholder="Enter your Alpaca API Key"
        />
      </div>
      <div class="mb-3">
        <label for="alpacaApiSecret" class="form-label"
          >Alpaca API Secret:</label
        >
        <input
          type="text"
          id="alpacaApiSecret"
          class="form-control"
          placeholder="Enter your Alpaca API Secret"
        />
      </div>
      <button id="saveKeys" class="btn btn-primary">Save Settings</button>
    </div>

    <!-- Main Chart & Tooltips -->
    <div id="chartContainer">
      <!-- Single tooltip for all series -->
      <div class="chart-tooltip" style="opacity: 0;"></div>
    </div>

    <!-- Volume Chart -->
    <div id="volumeChartContainer"></div>

    <!-- Debug Logs Section -->
    <div id="debugLogs"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/js/all.min.js"></script>
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    // Function to Append Debug Logs
    function appendDebugLog(message) {
      const debugLogs = document.getElementById("debugLogs");
      const logEntry = document.createElement("div");
      logEntry.textContent = message;
      debugLogs.appendChild(logEntry);
      // Auto-scroll to the bottom
      debugLogs.scrollTop = debugLogs.scrollHeight;
    }

    // Database Configuration (same as in portfolio.html)
    const dbName = "ProfitLadderDB";
    const positionsStoreName = "Positions";
    const settingsStoreName = "Settings";

    // Function to Open IndexedDB (same as in portfolio.html)
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 3);

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(positionsStoreName)) {
            const positionsStore = db.createObjectStore(positionsStoreName, {
              keyPath: "id",
            });
            positionsStore.createIndex("tickerSymbol", "tickerSymbol", {
              unique: false,
            });
          }
          if (!db.objectStoreNames.contains(settingsStoreName)) {
            db.createObjectStore(settingsStoreName, { keyPath: "key" });
          }
        };

        request.onsuccess = (event) => {
          resolve(event.target.result);
        };

        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    }

    // Function to Fetch Alpaca API Keys from IndexedDB
    async function getAlpacaApiKeys() {
      try {
        const db = await openDatabase();
        const transaction = db.transaction(settingsStoreName, "readonly");
        const store = transaction.objectStore(settingsStoreName);

        const getKey = (keyName) => {
          return new Promise((resolve, reject) => {
            const request = store.get(keyName);
            request.onsuccess = (event) => resolve(event.target.result?.value);
            request.onerror = (event) => reject(event.target.error);
          });
        };

        const alpacaApiKey = await getKey("APCA_API_KEY_ID");
        const alpacaApiSecret = await getKey("APCA_API_SECRET_KEY");

        return { alpacaApiKey, alpacaApiSecret };
      } catch (error) {
        console.error("Error fetching Alpaca API keys:", error);
        appendDebugLog(`Error fetching Alpaca API keys: ${error}`);
        return { alpacaApiKey: null, alpacaApiSecret: null };
      }
    }

    // Function to Fetch Historical Data with Pagination
    async function fetchHistoricalData(
      ticker,
      apiKey,
      apiSecret,
      timeframe = "15Min"
    ) {
      let bars = [];
      let page_token = null;
      const to = new Date();
      let from = new Date(to);
      const limit = 10000; // Adjust limit as needed

      // Adjust the 'from' date based on the timeframe
      switch (timeframe) {
        case "1Min":
          from.setDate(to.getDate() - 1); // 1 day
          break;
        case "5Min":
          from.setDate(to.getDate() - 7); // 7 days
          break;
        case "15Min":
          from.setDate(to.getDate() - 30); // 30 days
          break;
        case "30Min":
          from.setDate(to.getDate() - 60); // 60 days
          break;
        case "1H":
          from.setMonth(to.getMonth() - 3); // 3 months
          break;
        case "4H":
          from.setMonth(to.getMonth() - 12); // 12 months
          break;
        case "1D":
          from.setFullYear(to.getFullYear() - 2); // 2 years
          break;
        case "1W":
          from.setFullYear(to.getFullYear() - 5); // 5 years
          break;
        case "1M":
          from.setFullYear(to.getFullYear() - 10); // 10 years
          break;
        default:
          from.setDate(to.getDate() - 7);
          break;
      }

      let formattedFrom = from.toISOString().split("T")[0];
      let formattedTo = to.toISOString().split("T")[0];

      try {
        while (true) {
          const url = new URL(
            `https://data.alpaca.markets/v2/stocks/${ticker}/bars`
          );
          const params = {
            timeframe: timeframe,
            start: formattedFrom,
            end: formattedTo,
            limit: limit,
            adjustment: "all",
          };
          if (page_token) {
            params.page_token = page_token;
          }
          Object.keys(params).forEach((key) =>
            url.searchParams.append(key, params[key])
          );

          const response = await fetch(url, {
            method: "GET",
            headers: {
              "APCA-API-KEY-ID": apiKey,
              "APCA-API-SECRET-KEY": apiSecret,
            },
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("Raw historical data from Alpaca:", data);

          if (data.bars) {
            data.bars.forEach((bar) => {
              bars.push({
                time: new Date(bar.t).getTime() / 1000,
                open: bar.o,
                high: bar.h,
                low: bar.l,
                close: bar.c,
                volume: bar.v,
                trade_count: bar.n,
                vwap: bar.vw,
              });
            });
          } else {
            console.warn(
              `No historical data found for ${ticker} in this response.`
            );
            appendDebugLog(`No historical data found for ${ticker}.`);
            break; // Exit the loop if no data is found
          }

          // Check for next_page_token for pagination
          if (data.next_page_token) {
            page_token = data.next_page_token;
            console.log("Fetching next page with token:", page_token);
          } else {
            break; // No more pages, exit the loop
          }
        }
      } catch (error) {
        console.error("Error fetching historical data:", error);
        appendDebugLog(`Error fetching historical data: ${error}`);
        return [];
      }

      // Ensure bars are sorted in ascending order by time
      bars.sort((a, b) => a.time - b.time);

      return bars;
    }

    // Function to Fetch Real-time Data (latest minuteBar)
    async function fetchRealtimeData(ticker, apiKey, apiSecret) {
      const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${ticker}`;
      try {
        const response = await fetch(url, {
          headers: {
            "APCA-API-KEY-ID": apiKey,
            "APCA-API-SECRET-KEY": apiSecret,
          },
        });

        if (!response.ok) {
          console.error(
            "Failed to fetch snapshots from Alpaca:",
            response.statusText
          );
          appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
          return null;
        }

        const data = await response.json();

        if (data && data[ticker] && data[ticker].minuteBar) {
          const minuteBar = data[ticker].minuteBar;
          const realtimeData = {
            time: new Date(minuteBar.t).getTime() / 1000,
            open: minuteBar.o,
            high: minuteBar.h,
            low: minuteBar.l,
            close: minuteBar.c,
            volume: minuteBar.v,
            trade_count: minuteBar.n,
            vwap: minuteBar.vw,
          };
          console.log("Fetched real-time minute bar:", realtimeData);
          appendDebugLog("Fetched real-time minute bar from Alpaca.");
          return realtimeData;
        } else {
          console.error(`No real-time minute bar found for ${ticker}`);
          appendDebugLog(`No real-time minute bar found for ${ticker}`);
          return null;
        }
      } catch (error) {
        console.error("Error fetching real-time minute bar:", error);
        appendDebugLog(`Error fetching real-time minute bar: ${error}`);
        return null;
      }
    }

    // Global chart/series references
    let chart = null;
    let volumeChart = null;
    let candlestickSeries = null;
    let volumeSeries = null;
    let vwapSeries = null;
    let tradeCountSeries = null;

    let currentTicker = "";
    let currentTimeframe = "";

    async function createOrUpdateChart(ticker, timeframe, historicalData, realtimeData) {
      const chartContainer = document.getElementById("chartContainer");
      const volumeChartContainer = document.getElementById("volumeChartContainer");
      const tooltip = chartContainer.querySelector(".chart-tooltip");

      currentTicker = ticker;
      currentTimeframe = timeframe;

      // ----- Prepare data for each series -----

      // Candlestick data (just O/H/L/C/time)
      const candleData = historicalData.map((bar) => ({
        time: bar.time,
        open: bar.open,
        high: bar.high,
        low: bar.low,
        close: bar.close,
      }));

      // Volume data for histogram
      const volumeData = historicalData.map((bar) => ({
        time: bar.time,
        value: bar.volume,
      }));

      // VWAP data for line series
      const vwapData = historicalData.map((bar) => ({
        time: bar.time,
        value: bar.vwap,
      }));

      // trade_count data for line series
      const tradeCountData = historicalData.map((bar) => ({
        time: bar.time,
        value: bar.trade_count,
      }));

      // If the chart is already created, just update series data
      if (chart && volumeChart) {
        candlestickSeries.setData(candleData);
        volumeSeries.setData(volumeData);
        vwapSeries.setData(vwapData);
        tradeCountSeries.setData(tradeCountData);

        // If we have real-time data, update
        if (realtimeData) {
          const rtTime = realtimeData.time;

          candlestickSeries.update({
            time: rtTime,
            open: realtimeData.open,
            high: realtimeData.high,
            low: realtimeData.low,
            close: realtimeData.close,
          });
          volumeSeries.update({
            time: rtTime,
            value: realtimeData.volume,
          });
          vwapSeries.update({
            time: rtTime,
            value: realtimeData.vwap,
          });
          tradeCountSeries.update({
            time: rtTime,
            value: realtimeData.trade_count,
          });
        }

        updateChartTitle(ticker, timeframe);
        return;
      }

      // ----- Otherwise, create brand-new charts & series -----

      // Main Price Chart
      chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.offsetWidth,
        height: 400,
        layout: {
          backgroundColor: "#131722",
          textColor: "rgba(255, 255, 255, 0.9)",
        },
        grid: {
          vertLines: {
            color: "rgba(197, 203, 206, 0.5)",
          },
          horzLines: {
            color: "rgba(197, 203, 206, 0.5)",
          },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Magnet,
        },
        priceScale: {
          borderColor: "rgba(197, 203, 206, 0.8)",
        },
        timeScale: {
          borderColor: "rgba(197, 203, 206, 0.8)",
          timeVisible: true,
          secondsVisible: false,
        },
      });

      // Candlestick series (price)
      candlestickSeries = chart.addCandlestickSeries({
        upColor: "#4bffb5",
        downColor: "#ff4976",
        borderDownColor: "#ff4976",
        borderUpColor: "#4bffb5",
        wickDownColor: "#838ca1",
        wickUpColor: "#838ca1",
      });
      candlestickSeries.setData(candleData);

      // VWAP line series (same price scale as candlestick)
      vwapSeries = chart.addLineSeries({
        color: "yellow",
        lineWidth: 2,
        // priceScaleId: 'right'   // optionally set a different scale
      });
      vwapSeries.setData(vwapData);

      // trade_count line series on a separate price scale
      // so it doesn't mix with normal price scale
      tradeCountSeries = chart.addLineSeries({
        color: "purple",
        lineWidth: 2,
        priceScaleId: "left",
      });
      // Create a separate scale for the left side
      chart.priceScale("left").applyOptions({
        visible: true,
        borderVisible: true,
        borderColor: "rgba(197, 203, 206, 0.8)",
      });
      tradeCountSeries.setData(tradeCountData);

      // Volume Chart
      volumeChart = LightweightCharts.createChart(volumeChartContainer, {
        width: volumeChartContainer.offsetWidth,
        height: 100,
        layout: {
          backgroundColor: "#131722",
          textColor: "rgba(255, 255, 255, 0.9)",
        },
        grid: {
          vertLines: {
            color: "rgba(197, 203, 206, 0.5)",
          },
          horzLines: {
            color: "rgba(197, 203, 206, 0.5)",
          },
        },
        timeScale: {
          borderColor: "rgba(197, 203, 206, 0.8)",
          timeVisible: true,
          secondsVisible: false,
        },
        priceScale: {
          borderColor: "rgba(197, 203, 206, 0.8)",
          autoScale: true,
        },
      });

      // Volume histogram (separate chart)
      volumeSeries = volumeChart.addHistogramSeries({
        color: "#26a69a",
        lineWidth: 2,
        priceFormat: { type: "volume" }, // visually labeled as volume
      });
      volumeSeries.setData(volumeData);

      // If we have real-time data, update
      if (realtimeData) {
        const rtTime = realtimeData.time;
        candlestickSeries.update({
          time: rtTime,
          open: realtimeData.open,
          high: realtimeData.high,
          low: realtimeData.low,
          close: realtimeData.close,
        });
        volumeSeries.update({
          time: rtTime,
          value: realtimeData.volume,
        });
        vwapSeries.update({
          time: rtTime,
          value: realtimeData.vwap,
        });
        tradeCountSeries.update({
          time: rtTime,
          value: realtimeData.trade_count,
        });
      }

      updateChartTitle(ticker, timeframe);

      // Crosshair tooltip
      chart.subscribeCrosshairMove((param) => {
        if (!param.point) {
          tooltip.style.opacity = 0;
          return;
        }
        // Position the tooltip
        tooltip.style.left = param.point.x + "px";
        tooltip.style.top = param.point.y + "px";

        let tooltipContent = "";
        if (param.time) {
          const date = new Date(param.time * 1000);
          const formattedDate = date.toLocaleDateString();
          const formattedTime = date.toLocaleTimeString();
          tooltipContent += `<div><strong>${formattedDate} ${formattedTime}</strong></div>`;
        }

        // Retrieve each series' data from the crosshair
        const cndl = param.seriesData.get(candlestickSeries);
        const vol = param.seriesData.get(volumeSeries);
        const vw = param.seriesData.get(vwapSeries);
        const tc = param.seriesData.get(tradeCountSeries);

        // Candlestick info
        if (cndl) {
          tooltipContent += `
            <div>Open: ${cndl.open}</div>
            <div>High: ${cndl.high}</div>
            <div>Low: ${cndl.low}</div>
            <div>Close: ${cndl.close}</div>
          `;
        }

        // Volume info
        tooltipContent += `<div>Volume: ${vol?.value ?? "N/A"}</div>`;

        // VWAP info
        tooltipContent += `<div>VWAP: ${
          vw?.value ? vw.value.toFixed(4) : "N/A"
        }</div>`;

        // Trade Count info
        tooltipContent += `<div>Trade Count: ${
          tc?.value ?? "N/A"
        }</div>`;

        tooltip.innerHTML = tooltipContent;
        tooltip.style.opacity = 1;
      });

      chart.subscribeMouseLeave(() => {
        tooltip.style.opacity = 0;
      });
    }

    // Function to update the chart title
    function updateChartTitle(ticker, timeframe) {
      const title = `${ticker} - ${timeframe} - Real-time Chart`;
      chart.applyOptions({
        watermark: {
          visible: true,
          fontSize: 24,
          horzAlign: "left",
          vertAlign: "top",
          color: "rgba(255, 255, 255, 0.7)",
          text: title,
        },
      });
    }

    // Settings Toggle
    function handleSettingsToggle() {
      const settings = document.getElementById("settings");

      document.getElementById("settingsIcon").addEventListener("click", () => {
        settings.classList.toggle("d-none");
        appendDebugLog("Settings panel toggled.");
      });
    }

    // Save Keys
    async function handleSaveKeys() {
      document.getElementById("saveKeys").addEventListener("click", async () => {
        const alpacaApiKey = document
          .getElementById("alpacaApiKey")
          .value.trim();
        const alpacaApiSecret = document
          .getElementById("alpacaApiSecret")
          .value.trim();

        try {
          const db = await openDatabase();
          const transaction = db.transaction(settingsStoreName, "readwrite");
          const store = transaction.objectStore(settingsStoreName);

          if (alpacaApiKey) {
            store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
          }
          if (alpacaApiSecret) {
            store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
          }

          await new Promise((resolve, reject) => {
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) => reject(event.target.error);
          });

          appendDebugLog("API keys saved successfully.");
          alert("API keys saved successfully.");
        } catch (error) {
          console.error("Error saving API keys:", error);
          appendDebugLog(`Error saving API keys: ${error}`);
          alert("Failed to save API keys. Please try again.");
        }
      });
    }

    // Update Chart Data
    async function updateChartData(ticker, timeframe) {
      if (!ticker) {
        alert("Please enter a ticker symbol.");
        return;
      }

      const { alpacaApiKey, alpacaApiSecret } = await getAlpacaApiKeys();
      if (!alpacaApiKey || !alpacaApiSecret) {
        alert("Alpaca API keys are not set. Please enter them in the settings.");
        return;
      }

      const historicalData = await fetchHistoricalData(ticker, alpacaApiKey, alpacaApiSecret, timeframe);
      const realtimeData = await fetchRealtimeData(ticker, alpacaApiKey, alpacaApiSecret);

      createOrUpdateChart(ticker, timeframe, historicalData, realtimeData);
    }

    // Initialize Chart with defaults or query params
    async function initializeChart() {
      const urlParams = new URLSearchParams(window.location.search);
      const tickerInput = document.getElementById("tickerInput");
      const timeframeButtons = document.querySelectorAll(".timeframe-button");

      const ticker = (urlParams.get("ticker") || "AAPL").toUpperCase(); // default
      const timeframe = urlParams.get("timeframe") || "5Min"; // default

      tickerInput.value = ticker;

      timeframeButtons.forEach((button) => {
        button.classList.remove("active");
        if (button.dataset.timeframe === timeframe) {
          button.classList.add("active");
        }
      });

      updateChartData(ticker, timeframe);
    }

    // Update URL parameters
    function updateUrlParams(ticker, timeframe) {
      const urlParams = new URLSearchParams(window.location.search);
      urlParams.set("ticker", ticker);
      urlParams.set("timeframe", timeframe);
      const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
      window.history.pushState({ path: newUrl }, "", newUrl);
    }

    // Initialize the Application
    async function initializeApp() {
      handleSettingsToggle();
      handleSaveKeys();

      const tickerInput = document.getElementById("tickerInput");
      const timeframeButtons = document.querySelectorAll(".timeframe-button");

      tickerInput.addEventListener("change", (event) => {
        const newTicker = event.target.value.toUpperCase();
        const currentActiveTimeframeButton =
          document.querySelector(".timeframe-button.active");
        const currentTimeframe = currentActiveTimeframeButton
          ? currentActiveTimeframeButton.dataset.timeframe
          : "5Min";
        updateUrlParams(newTicker, currentTimeframe);
        updateChartData(newTicker, currentTimeframe);
      });

      timeframeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          timeframeButtons.forEach((btn) => btn.classList.remove("active"));
          button.classList.add("active");
          const newTimeframe = button.dataset.timeframe;
          const ticker = document.getElementById("tickerInput").value.toUpperCase();
          updateUrlParams(ticker, newTimeframe);
          updateChartData(ticker, newTimeframe);
        });
      });

      initializeChart();
    }

    window.addEventListener("load", initializeApp);
  </script>
</body>
v20241222092800
</html>
