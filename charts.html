--- START OF FILE charts.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Real-time Stock Chart</title>
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css"
    rel="stylesheet"
  />
  <link
    rel="stylesheet"
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/css/all.min.css"
  />
  <style>
    body {
      background-color: #121212;
      color: #ffffff;
      font-family: Arial, sans-serif;
    }
    #chartContainer {
      width: 90%;
      height: 600px; /* Increased height to better accommodate multiple series */
      margin: 20px auto 10px;
      background-color: #131722;
      position: relative; /* For tooltip positioning */
    }
    .settings-toggle {
      cursor: pointer;
      font-size: 20px;
      text-align: right;
      margin-bottom: 10px;
      margin-top: 20px;
    }
    .settings-toggle:hover {
      color: #00bcd4;
    }
    .settings {
      margin-top: 20px;
      background-color: #1e1e1e;
      padding: 20px;
      border-radius: 5px;
    }
    .btn-primary {
      background-color: #007bff;
      color: #fff;
      border: none;
    }
    /* Debug Logs Styling */
    #debugLogs {
      background-color: #1e1e1e;
      padding: 10px;
      border: 1px solid #444;
      max-height: 200px;
      overflow-y: auto;
      margin-top: 20px;
      font-family: monospace;
      color: #ff6f61;
    }
    /* Chart Controls Styling */
    #chartControls {
      margin-top: 20px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #chartControls label {
      color: #ffffff;
    }
    #chartControls input {
      background-color: #1e1e1e;
      color: #ffffff;
      border: 1px solid #444;
      padding: 5px 10px;
      border-radius: 4px;
    }
    .timeframe-buttons {
      display: flex;
      gap: 5px;
      align-items: center;
    }
    .timeframe-button {
      background-color: #343a40;
      color: #fff;
      border: none;
      padding: 5px 8px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
    }
    .timeframe-button:hover {
      background-color: #555e64;
    }
    .timeframe-button.active {
      background-color: #007bff;
    }
    /* Tooltip Styling */
    .chart-tooltip {
      position: absolute;
      z-index: 10;
      background: rgba(0, 0, 0, 0.8);
      color: #fff;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <!-- Navigation Bar -->
  <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <div class="container-fluid">
      <a class="navbar-brand" href="./"><i class="fas fa-calculator"></i> Profit Ladder</a>
      <button
        class="navbar-toggler"
        type="button"
        data-bs-toggle="collapse"
        data-bs-target="#navbarNav"
        aria-controls="navbarNav"
        aria-expanded="false"
        aria-label="Toggle navigation"
      >
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav me-auto mb-2 mb-lg-0">
          <li class="nav-item">
            <a class="nav-link" href="./">Profit Ladder</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="./portfolio.html">Portfolio</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="./charts.html">Charts</a>
          </li>
        </ul>
      </div>
    </div>
   </nav>

  <div class="container">
    <!-- Chart Controls -->
    <div id="chartControls">
      <label for="tickerInput">Ticker:</label>
      <input type="text" id="tickerInput" placeholder="Enter ticker symbol" />
      <div class="timeframe-buttons">
        <label>Timeframe:</label>
        <button class="timeframe-button" data-timeframe="1Min">1m</button>
        <button class="timeframe-button active" data-timeframe="5Min">5m</button>
        <button class="timeframe-button" data-timeframe="15Min">15m</button>
        <button class="timeframe-button" data-timeframe="30Min">30m</button>
        <button class="timeframe-button" data-timeframe="1H">1H</button>
        <button class="timeframe-button" data-timeframe="4H">4H</button>
        <button class="timeframe-button" data-timeframe="1D">1D</button>
        <button class="timeframe-button" data-timeframe="1W">1W</button>
        <button class="timeframe-button" data-timeframe="1M">1M</button>
      </div>
    </div>

    <div class="settings-toggle text-end mt-4">
      <span id="settingsIcon"><i class="fas fa-cog"></i> Settings</span>
    </div>

    <!-- Settings Section -->
    <div class="settings d-none" id="settings">
      <h3>Settings</h3>
      <!-- API Keys Section -->
      <div class="mb-3">
        <label for="alpacaApiKey" class="form-label">Alpaca API Key:</label>
        <input
          type="text"
          id="alpacaApiKey"
          class="form-control"
          placeholder="Enter your Alpaca API Key"
        />
      </div>
      <div class="mb-3">
        <label for="alpacaApiSecret" class="form-label">Alpaca API Secret:</label>
        <input
          type="text"
          id="alpacaApiSecret"
          class="form-control"
          placeholder="Enter your Alpaca API Secret"
        />
      </div>
      <button id="saveKeys" class="btn btn-primary">Save Settings</button>
    </div>

    <!-- Single Chart + Tooltip -->
    <div id="chartContainer">
      <div class="chart-tooltip" style="opacity: 0;"></div>
    </div>

    <!-- Debug Logs Section -->
    <div id="debugLogs"></div>
  </div>

  <!-- Bootstrap JS and Dependencies -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Font Awesome JS for Icons -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.3.0/js/all.min.js"></script>
  <!-- Lightweight Charts -->
  <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
  <script>
    // Function to Append Debug Logs
    function appendDebugLog(message) {
      const debugLogs = document.getElementById("debugLogs");
      if (!debugLogs) {
        console.error("Debug Logs element not found in the DOM.");
        return;
      }
      const logEntry = document.createElement("div");
      logEntry.textContent = message;
      debugLogs.appendChild(logEntry);
      // Auto-scroll to the bottom
      debugLogs.scrollTop = debugLogs.scrollHeight;
    }

    // Database Configuration
    const dbName = "ProfitLadderDB";
    const settingsStoreName = "Settings";

    // Function to Open IndexedDB
    function openDatabase() {
      return new Promise((resolve, reject) => {
        const request = indexedDB.open(dbName, 3); // Increment version if schema changes

        request.onupgradeneeded = (event) => {
          const db = event.target.result;
          if (!db.objectStoreNames.contains(settingsStoreName)) {
            db.createObjectStore(settingsStoreName, { keyPath: "key" });
          }
        };

        request.onsuccess = (event) => {
          resolve(event.target.result);
        };

        request.onerror = (event) => {
          reject(event.target.error);
        };
      });
    }

    // Function to Fetch Alpaca API Keys from IndexedDB
    async function getAlpacaApiKeys() {
      try {
        const db = await openDatabase();
        const transaction = db.transaction(settingsStoreName, "readonly");
        const store = transaction.objectStore(settingsStoreName);

        const getKey = (keyName) => {
          return new Promise((resolve, reject) => {
            const request = store.get(keyName);
            request.onsuccess = (event) => resolve(event.target.result?.value);
            request.onerror = (event) => reject(event.target.error);
          });
        };

        const alpacaApiKey = await getKey("APCA_API_KEY_ID");
        const alpacaApiSecret = await getKey("APCA_API_SECRET_KEY");

        return { alpacaApiKey, alpacaApiSecret };
      } catch (error) {
        console.error("Error fetching Alpaca API keys:", error);
        appendDebugLog(`Error fetching Alpaca API keys: ${error}`);
        return { alpacaApiKey: null, alpacaApiSecret: null };
      }
    }

    // Function to Fetch Historical Data from Alpaca with Pagination
    async function fetchHistoricalData(ticker, apiKey, apiSecret, timeframe = "15Min") {
      let bars = [];
      let page_token = null;
      const to = new Date();
      let from = new Date(to);
      const limit = 10000; // Adjust limit as needed

      // Adjust the 'from' date based on the timeframe
      switch (timeframe) {
        case "1Min":
          from.setDate(to.getDate() - 1); // 1 day
          break;
        case "5Min":
          from.setDate(to.getDate() - 7); // 7 days
          break;
        case "15Min":
          from.setDate(to.getDate() - 30); // 30 days
          break;
        case "30Min":
          from.setDate(to.getDate() - 60); // 60 days
          break;
        case "1H":
          from.setMonth(to.getMonth() - 3); // 3 months
          break;
        case "4H":
          from.setMonth(to.getMonth() - 12); // 12 months
          break;
        case "1D":
          from.setFullYear(to.getFullYear() - 2); // 2 years
          break;
        case "1W":
          from.setFullYear(to.getFullYear() - 5); // 5 years
          break;
        case "1M":
          from.setFullYear(to.getFullYear() - 10); // 10 years
          break;
        default:
          from.setDate(to.getDate() - 7);
          break;
      }

      let formattedFrom = from.toISOString().split("T")[0];
      let formattedTo = to.toISOString().split("T")[0];

      try {
        while (true) {
          const url = new URL(`https://data.alpaca.markets/v2/stocks/${ticker}/bars`);
          const params = {
            timeframe: timeframe,
            start: formattedFrom,
            end: formattedTo,
            limit: limit,
            adjustment: "all",
          };
          if (page_token) {
            params.page_token = page_token;
          }
          Object.keys(params).forEach((key) =>
            url.searchParams.append(key, params[key])
          );

          const response = await fetch(url, {
            method: "GET",
            headers: {
              "APCA-API-KEY-ID": apiKey,
              "APCA-API-SECRET-KEY": apiSecret,
            },
          });

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();
          console.log("Raw historical data from Alpaca:", data);

          if (data.bars) {
            data.bars.forEach((bar) => {
              bars.push({
                time: new Date(bar.t).getTime() / 1000,
                open: bar.o,
                high: bar.h,
                low: bar.l,
                close: bar.c,
                volume: bar.v,
                trade_count: bar.n,
                vwap: bar.vw,
              });
            });
          } else {
            console.warn(`No historical data found for ${ticker} in this response.`);
            appendDebugLog(`No historical data found for ${ticker} in this response.`);
            break; // Exit the loop if no data is found
          }

          // Check for next_page_token for pagination
          if (data.next_page_token) {
            page_token = data.next_page_token;
            console.log("Fetching next page with token:", page_token);
          } else {
            break; // No more pages
          }
        }
      } catch (error) {
        console.error("Error fetching historical data:", error);
        appendDebugLog(`Error fetching historical data: ${error}`);
        return [];
      }

      // Ensure bars are sorted in ascending order by time
      bars.sort((a, b) => a.time - b.time);

      return bars;
    }

    // Function to Fetch Real-time Data (latest minuteBar) from Alpaca
    async function fetchRealtimeData(ticker, apiKey, apiSecret, lastHistoricalTimestamp) {
      const url = `https://data.alpaca.markets/v2/stocks/snapshots?symbols=${ticker}`;
      try {
        const response = await fetch(url, {
          headers: {
            "APCA-API-KEY-ID": apiKey,
            "APCA-API-SECRET-KEY": apiSecret,
          },
        });

        if (!response.ok) {
          console.error(
            "Failed to fetch snapshots from Alpaca:",
            response.statusText
          );
          appendDebugLog(`Failed to fetch snapshots from Alpaca: ${response.statusText}`);
          return null;
        }

        const data = await response.json();

        if (data && data[ticker] && data[ticker].minuteBar) {
          const minuteBar = data[ticker].minuteBar;
          const realtimeData = {
            time: new Date(minuteBar.t).getTime() / 1000,
            open: minuteBar.o,
            high: minuteBar.h,
            low: minuteBar.l,
            close: minuteBar.c,
            volume: minuteBar.v,
            trade_count: minuteBar.n,
            vwap: minuteBar.vw,
          };
          console.log("Fetched real-time minute bar:", realtimeData);
          appendDebugLog("Fetched real-time minute bar from Alpaca.");

          // If the realtime bar is after the last historical bar, fetch additional minute bars
          if (realtimeData.time > lastHistoricalTimestamp) {
            // Fetch minute bars since lastHistoricalTimestamp
            const additionalBars = await fetchAdditionalMinuteBars(ticker, apiKey, apiSecret, lastHistoricalTimestamp);
            return { realtimeData, additionalBars };
          }

          return { realtimeData };
        } else {
          console.error(`No real-time minute bar found for ${ticker}`);
          appendDebugLog(`No real-time minute bar found for ${ticker}`);
          return null;
        }
      } catch (error) {
        console.error("Error fetching real-time minute bar:", error);
        appendDebugLog(`Error fetching real-time minute bar: ${error}`);
        return null;
      }
    }

    // Function to Fetch Additional Minute Bars Since Last Historical Timestamp
    async function fetchAdditionalMinuteBars(ticker, apiKey, apiSecret, lastTimestamp) {
      // Calculate the start time as lastTimestamp + 60 seconds
      const startTime = new Date((lastTimestamp + 60) * 1000).toISOString();
      const endTime = new Date().toISOString();

      const url = new URL(`https://data.alpaca.markets/v2/stocks/${ticker}/bars`);
      const params = {
        timeframe: "1Min",
        start: startTime,
        end: endTime,
        limit: 1000,
        adjustment: "all",
      };

      Object.keys(params).forEach((key) =>
        url.searchParams.append(key, params[key])
      );

      try {
        const response = await fetch(url, {
          method: "GET",
          headers: {
            "APCA-API-KEY-ID": apiKey,
            "APCA-API-SECRET-KEY": apiSecret,
          },
        });

        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();
        console.log("Fetched additional minute bars:", data);

        if (data.bars) {
          const additionalBars = data.bars.map((bar) => ({
            time: new Date(bar.t).getTime() / 1000,
            open: bar.o,
            high: bar.h,
            low: bar.l,
            close: bar.c,
            volume: bar.v,
            trade_count: bar.n,
            vwap: bar.vw,
          }));
          return additionalBars;
        } else {
          console.warn(`No additional minute bars found for ${ticker} in this response.`);
          appendDebugLog(`No additional minute bars found for ${ticker} in this response.`);
          return [];
        }
      } catch (error) {
        console.error("Error fetching additional minute bars:", error);
        appendDebugLog(`Error fetching additional minute bars: ${error}`);
        return [];
      }
    }

    // Global references
    let chart = null;
    let candlestickSeries = null;
    let volumeSeries = null;
    let vwapSeries = null;
    let tradeCountSeries = null;

    let currentTicker = "";
    let currentTimeframe = "";
    let lastHistoricalTimestamp = 0; // To track the last timestamp from historical data

    async function createOrUpdateChart(ticker, timeframe, historicalData, realtimeData) {
      const chartContainer = document.getElementById("chartContainer");
      const tooltip = chartContainer.querySelector(".chart-tooltip");

      currentTicker = ticker;
      currentTimeframe = timeframe;

      // --- Prepare data for each series ---
      const candleData = historicalData.map((bar) => ({
        time: bar.time,
        open: bar.open,
        high: bar.high,
        low: bar.low,
        close: bar.close,
      }));

      const volumeData = historicalData.map((bar) => ({
        time: bar.time,
        value: bar.volume,
      }));

      const vwapData = historicalData.map((bar) => ({
        time: bar.time,
        value: bar.vwap,
      }));

      const tradeCountData = historicalData.map((bar) => ({
        time: bar.time,
        value: bar.trade_count,
      }));

      // Update lastHistoricalTimestamp
      if (historicalData.length > 0) {
        lastHistoricalTimestamp = historicalData[historicalData.length - 1].time;
      }

      // Calculate Volume Min and Max for Scaling Trade Count
      const volumeValues = volumeData.map(d => d.value);
      const volumeMin = Math.min(...volumeValues, 0); // Ensure at least 0
      const volumeMax = Math.max(...volumeValues);

      // If chart already exists, just update
      if (chart) {
        candlestickSeries.setData(candleData);
        volumeSeries.setData(volumeData);
        vwapSeries.setData(vwapData);
        tradeCountSeries.setData(tradeCountData);

        // Update the trade_count scale based on new volume data
        chart.priceScale("left").applyOptions({
          min: 0, // Align with volume's bottom
          max: volumeMax,
        });

        // Handle real-time data
        if (realtimeData) {
          if (realtimeData.additionalBars && realtimeData.additionalBars.length > 0) {
            realtimeData.additionalBars.forEach(bar => {
              candlestickSeries.update({
                time: bar.time,
                open: bar.open,
                high: bar.high,
                low: bar.low,
                close: bar.close,
              });
              volumeSeries.update({
                time: bar.time,
                value: bar.volume,
              });
              vwapSeries.update({
                time: bar.time,
                value: bar.vwap,
              });
              tradeCountSeries.update({
                time: bar.time,
                value: bar.trade_count,
              });
            });
          }

          if (realtimeData.realtimeData) {
            const rt = realtimeData.realtimeData;
            candlestickSeries.update({
              time: rt.time,
              open: rt.open,
              high: rt.high,
              low: rt.low,
              close: rt.close,
            });
            volumeSeries.update({
              time: rt.time,
              value: rt.volume,
            });
            vwapSeries.update({
              time: rt.time,
              value: rt.vwap,
            });
            tradeCountSeries.update({
              time: rt.time,
              value: rt.trade_count,
            });
          }
        }

        updateChartTitle(ticker, timeframe);
        return;
      }

      // Otherwise, create a brand-new chart
      chart = LightweightCharts.createChart(chartContainer, {
        width: chartContainer.offsetWidth,
        height: 600, // Increased height to better accommodate multiple series
        layout: {
          backgroundColor: "#131722", // Corrected property name
          textColor: "rgba(255, 255, 255, 0.9)",
        },
        grid: {
          vertLines: {
            color: "rgba(197, 203, 206, 0.5)",
          },
          horzLines: {
            color: "rgba(197, 203, 206, 0.5)",
          },
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Magnet,
        },
        priceScale: {
          borderColor: "rgba(197, 203, 206, 0.8)",
        },
        timeScale: {
          borderColor: "rgba(197, 203, 206, 0.8)",
          timeVisible: true,
          secondsVisible: false,
        },
      });

      // Main candlestick
      candlestickSeries = chart.addCandlestickSeries({
        upColor: "#4bffb5",
        downColor: "#ff4976",
        borderDownColor: "#ff4976",
        borderUpColor: "#4bffb5",
        wickDownColor: "#838ca1",
        wickUpColor: "#838ca1",
      });
      candlestickSeries.setData(candleData);

      // Volume histogram on default (right) price scale
      volumeSeries = chart.addHistogramSeries({
        color: "#26a69a",
        lineWidth: 2,
        priceFormat: { type: "volume" },
        priceScaleId: "", // default scale
      });
      volumeSeries.setData(volumeData);

      // Adjust scale margins to allocate bottom 30% for volume
      chart.priceScale("").applyOptions({
        scaleMargins: {
          top: 0.7,     // top 70% for candlesticks and main series
          bottom: 0,
        },
      });

      // VWAP line on main price scale
      vwapSeries = chart.addLineSeries({
        color: "yellow",
        lineWidth: 2,
      });
      vwapSeries.setData(vwapData);

      // Trade count line on 'left' price scale
      tradeCountSeries = chart.addLineSeries({
        color: "purple",
        lineWidth: 1,
        priceScaleId: "left",
      });
      chart.priceScale("left").applyOptions({
        visible: true,
        borderVisible: true,
        borderColor: "rgba(197, 203, 206, 0.8)",
        min: 0, // Align bottom with volume
        max: volumeMax,
      });
      tradeCountSeries.setData(tradeCountData);

      // Handle real-time data
      if (realtimeData) {
        if (realtimeData.additionalBars && realtimeData.additionalBars.length > 0) {
          realtimeData.additionalBars.forEach(bar => {
            candlestickSeries.update({
              time: bar.time,
              open: bar.open,
              high: bar.high,
              low: bar.low,
              close: bar.close,
            });
            volumeSeries.update({
              time: bar.time,
              value: bar.volume,
            });
            vwapSeries.update({
              time: bar.time,
              value: bar.vwap,
            });
            tradeCountSeries.update({
              time: bar.time,
              value: bar.trade_count,
            });
          });
        }

        if (realtimeData.realtimeData) {
          const rt = realtimeData.realtimeData;
          candlestickSeries.update({
            time: rt.time,
            open: rt.open,
            high: rt.high,
            low: rt.low,
            close: rt.close,
          });
          volumeSeries.update({
            time: rt.time,
            value: rt.volume,
          });
          vwapSeries.update({
            time: rt.time,
            value: rt.vwap,
          });
          tradeCountSeries.update({
            time: rt.time,
            value: rt.trade_count,
          });
        }
      }

      updateChartTitle(ticker, timeframe);

      // Crosshair event => single tooltip
      chart.subscribeCrosshairMove((param) => {
        if (!param.point) {
          tooltip.style.opacity = 0;
          return;
        }

        tooltip.style.left = param.point.x + "px";
        tooltip.style.top = param.point.y + "px";

        let tooltipContent = "";
        if (param.time) {
          const date = new Date(param.time * 1000);
          const formattedDate = date.toLocaleDateString();
          const formattedTime = date.toLocaleTimeString();
          tooltipContent += `<div><strong>${formattedDate} ${formattedTime}</strong></div>`;
        }

        // Retrieve data from each series
        const cndl = param.seriesData.get(candlestickSeries);
        const vol = param.seriesData.get(volumeSeries);
        const vw = param.seriesData.get(vwapSeries);
        const tc = param.seriesData.get(tradeCountSeries);

        // Candlestick info
        if (cndl) {
          tooltipContent += `
            <div>Open: ${cndl.open}</div>
            <div>High: ${cndl.high}</div>
            <div>Low: ${cndl.low}</div>
            <div>Close: ${cndl.close}</div>
          `;
        }

        // Volume info
        tooltipContent += `<div>Volume: ${vol?.value ?? "N/A"}</div>`;

        // VWAP info
        tooltipContent += `<div>VWAP: ${
          vw?.value ? vw.value.toFixed(4) : "N/A"
        }</div>`;

        // Trade Count info
        tooltipContent += `<div>Trade Count: ${
          tc?.value ?? "N/A"
        }</div>`;

        tooltip.innerHTML = tooltipContent;
        tooltip.style.opacity = 1;
      });

      chart.subscribeMouseLeave(() => {
        tooltip.style.opacity = 0;
      });
    }

    function updateChartTitle(ticker, timeframe) {
      const title = `${ticker} - ${timeframe} - Real-time Chart`;
      chart.applyOptions({
        watermark: {
          visible: true,
          fontSize: 24,
          horzAlign: "left",
          vertAlign: "top",
          color: "rgba(255, 255, 255, 0.7)",
          text: title,
        },
      });
    }

    // Settings Toggle
    function handleSettingsToggle() {
      const settings = document.getElementById("settings");
      document.getElementById("settingsIcon").addEventListener("click", () => {
        settings.classList.toggle("d-none");
        appendDebugLog("Settings panel toggled.");
      });
    }

    // Save Keys
    async function handleSaveKeys() {
      document.getElementById("saveKeys").addEventListener("click", async () => {
        const alpacaApiKey = document
          .getElementById("alpacaApiKey")
          .value.trim();
        const alpacaApiSecret = document
          .getElementById("alpacaApiSecret")
          .value.trim();

        try {
          const db = await openDatabase();
          const transaction = db.transaction(settingsStoreName, "readwrite");
          const store = transaction.objectStore(settingsStoreName);

          if (alpacaApiKey) {
            store.put({ key: "APCA_API_KEY_ID", value: alpacaApiKey });
          }
          if (alpacaApiSecret) {
            store.put({ key: "APCA_API_SECRET_KEY", value: alpacaApiSecret });
          }

          await new Promise((resolve, reject) => {
            transaction.oncomplete = () => resolve();
            transaction.onerror = (event) => reject(event.target.error);
          });

          appendDebugLog("API keys saved successfully.");
          alert("API keys saved successfully.");
        } catch (error) {
          console.error("Error saving API keys:", error);
          appendDebugLog(`Error saving API keys: ${error}`);
          alert("Failed to save API keys. Please try again.");
        }
      });
    }

    // Update Chart Data
    async function updateChartData(ticker, timeframe) {
      if (!ticker) {
        alert("Please enter a ticker symbol.");
        return;
      }

      const { alpacaApiKey, alpacaApiSecret } = await getAlpacaApiKeys();
      if (!alpacaApiKey || !alpacaApiSecret) {
        alert("Alpaca API keys are not set. Please enter them in the settings.");
        return;
      }

      const historicalData = await fetchHistoricalData(ticker, alpacaApiKey, alpacaApiSecret, timeframe);
      const lastHistoricalTimestamp = historicalData.length > 0 ? historicalData[historicalData.length - 1].time : 0;
      const realtimeData = await fetchRealtimeData(ticker, alpacaApiKey, alpacaApiSecret, lastHistoricalTimestamp);

      if (!realtimeData) {
        appendDebugLog("No real-time data fetched.");
        return;
      }

      createOrUpdateChart(ticker, timeframe, historicalData, realtimeData);
    }

    // Initialize Chart with default or query params
    async function initializeChart() {
      const urlParams = new URLSearchParams(window.location.search);
      const tickerInput = document.getElementById("tickerInput");
      const timeframeButtons = document.querySelectorAll(".timeframe-button");

      const ticker = (urlParams.get("ticker") || "AAPL").toUpperCase(); // default
      const timeframe = urlParams.get("timeframe") || "5Min"; // default

      tickerInput.value = ticker;
      timeframeButtons.forEach((button) => {
        button.classList.remove("active");
        if (button.dataset.timeframe === timeframe) {
          button.classList.add("active");
        }
      });

      updateChartData(ticker, timeframe);
    }

    // Update URL parameters
    function updateUrlParams(ticker, timeframe) {
      const urlParams = new URLSearchParams(window.location.search);
      urlParams.set("ticker", ticker);
      urlParams.set("timeframe", timeframe);
      const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
      window.history.pushState({ path: newUrl }, "", newUrl);
    }

    // Initialize the Application
    async function initializeApp() {
      handleSettingsToggle();
      handleSaveKeys();

      const tickerInput = document.getElementById("tickerInput");
      const timeframeButtons = document.querySelectorAll(".timeframe-button");

      tickerInput.addEventListener("change", (event) => {
        const newTicker = event.target.value.toUpperCase();
        const activeBtn = document.querySelector(".timeframe-button.active");
        const activeTimeframe = activeBtn ? activeBtn.dataset.timeframe : "5Min";
        updateUrlParams(newTicker, activeTimeframe);
        updateChartData(newTicker, activeTimeframe);
      });

      timeframeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          timeframeButtons.forEach((b) => b.classList.remove("active"));
          button.classList.add("active");
          const newTimeframe = button.dataset.timeframe;
          const ticker = document.getElementById("tickerInput").value.toUpperCase();
          updateUrlParams(ticker, newTimeframe);
          updateChartData(ticker, newTimeframe);
        });
      });

      initializeChart();

      // Set up real-time updates based on timeframe
      setupRealTimeUpdates();
    }

    window.addEventListener("load", initializeApp);

    // Function to Set Up Real-time Updates
    let refreshIntervalId; // Declare refreshIntervalId outside the function

    function setupRealTimeUpdates() {
      const timeframeButtons = document.querySelectorAll(".timeframe-button");
      timeframeButtons.forEach((button) => {
        button.addEventListener("click", () => {
          const newTimeframe = button.dataset.timeframe;
          if (refreshIntervalId) {
            clearInterval(refreshIntervalId);
          }
          // Set refresh interval based on timeframe
          const interval = getRefreshInterval(newTimeframe);
          if (interval) {
            refreshIntervalId = setInterval(() => {
              const ticker = document.getElementById("tickerInput").value.toUpperCase();
              if (ticker) {
                updateChartData(ticker, newTimeframe);
              }
            }, interval);
          }
        });
      });

      // Initialize the first interval
      const activeBtn = document.querySelector(".timeframe-button.active");
      const activeTimeframe = activeBtn ? activeBtn.dataset.timeframe : "5Min";
      const initialInterval = getRefreshInterval(activeTimeframe);
      if (initialInterval) {
        refreshIntervalId = setInterval(() => {
          const ticker = document.getElementById("tickerInput").value.toUpperCase();
          if (ticker) {
            updateChartData(ticker, activeTimeframe);
          }
        }, initialInterval);
      }
    }

    // Function to Determine Refresh Interval Based on Timeframe
    function getRefreshInterval(timeframe) {
      switch (timeframe) {
        case "1Min":
        case "5Min":
        case "15Min":
        case "30Min":
          return 60000; // 1 minute
        case "1H":
        case "4H":
          return 300000; // 5 minutes
        case "1D":
        case "1W":
        case "1M":
          return 900000; // 15 minutes
        default:
          return 60000; // Default to 1 minute
      }
    }
  </script>
</body>
v20241222114200
</html>